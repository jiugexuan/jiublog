---
title: 【RFC】RFC 3552 互联网威胁模型
date: 2022-2-18 15:00:00 +/-0800
categories: [BLOG,RFC]
tags: [RFC]     # TAG names should always be lowercase 标记名称应始终为小写
---

<div style="text-align:left;">Network Working Group
  <span style="float:right;">E. Rescorla</span>
</div>
<div style="text-align:left;">Request for Comments: 3552  
  <span style="float:right;">RTFM, Inc.</span>
</div>
<div style="text-align:left;">BCP: 72  
  <span style="float:right;">B. Korver</span>
</div>
<div style="text-align:left;">Category: Best Current Practice  
  <span style="float:right;">Xythos Software</span>
</div>

<div align="right">Internet Architecture Board</div>
<div align="right">IAB</div>
<div align="right"> July 2003</div>


# 关于安全考虑的RFC文本编写指南 Guidelines for Writing RFC Text on Security Considerations

## 本备忘录的状态 Status of this Memo
  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.  Distribution of this memo is unlimited.

  本文件规定了互联网社区的最佳实践，并要求讨论和提出改进建议。本备忘录的分发不受限制。

## 版权声明 Copyright Notice

  Copyright (C) The Internet Society (2003).  All Rights Reserved.

  版权所有 (C) 互联网协会 (2003)。 版权所有。

## 摘要 Abstract

   All RFCs are required to have a Security Considerations section. Historically, such sections have been relatively weak.  This document provides guidelines to RFC authors on how to write a good Security Considerations section.

   所有 RFC 都必须有一个安全注意事项部分。 从历史上看，这些部分相对薄弱。 本文档为 RFC 作者提供了如何编写良好的安全注意事项部分的指南。

## 目录 Table of Contents

[toc]

## 1. 介绍 Introduction

   All RFCs are required by RFC 2223 to contain a Security Considerations section.  The purpose of this is both to encourage document authors to consider security in their designs and to inform the reader of relevant security issues.  This memo is intended to provide guidance to RFC authors in service of both ends.

   RFC 2223要求所有RFC包含安全注意事项部分。这样做的目的是鼓励文档作者在设计中考虑安全性，并向读者告知相关的安全问题。本备忘录旨在为服务于双方的RFC作者提供指导。

   This document is structured in three parts.  The first is a combination security tutorial and definition of common terms; the second is a series of guidelines for writing Security Considerations; the third is a series of examples.

   本文件由三部分组成。第一个是安全教程和通用术语的定义；第二个是一系列编写安全注意事项的指南；第三个是一系列的例子。

### 1.1. 要求 Requirements

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in thisdocument are to be interpreted as described in BCP 14, RFC 2119 [KEYWORDS].

   本文件中的关键词“必须”、“不得”、“要求”、“应”、“不应”、“应该”、“不应”、“推荐”、“可以”和“可选”是为了 按照 BCP 14, RFC 2119 [KEYWORDS] 中的描述进行解释。

## 2. 安全的目标 The Goals of Security

   Most people speak of security as if it were a single monolithic property of a protocol or system, however, upon reflection, one realizes that it is clearly not true.  Rather, security is a series of related but somewhat independent properties.  Not all of these properties are required for every application.

   大多数人谈到安全性时，就好像它是协议或系统的一个单一的整体属性，然而，经过反思，人们意识到这显然不是真的。更确切地说，安全是一系列相关但多少有些独立的属性。并不是每个应用程序都需要这些属性。

   We can loosely divide security goals into those related to protecting communications (COMMUNICATION SECURITY, also known as COMSEC) and those relating to protecting systems (ADMINISTRATIVE SECURITY or SYSTEM SECURITY).  Since communications are carried out by systems and access to systems is through communications channels, these goals obviously interlock, but they can also be independently provided.

   我们可以将安全目标大致分为与保护通信相关的目标（通信安全 COMMUNICATION SECURITY，也称为COMSEC）和与保护系统相关的目标（管理安全或系统安全）。由于通信是由系统执行的，而对系统的访问是通过通信通道进行的，因此这些目标显然是相互关联的，但它们也可以独立提供。

### 2.1. 通讯安全 Communication Security

   Different authors partition the goals of communication security differently.  The partitioning we've found most useful is to divide them into three major categories: CONFIDENTIALITY, DATA INTEGRITY and PEER ENTITY AUTHENTICATION.

   不同的作者对通信安全的目标进行了不同的划分。我们发现最有用的分区是将它们分为三个主要类别:机密性、数据完整性和对等实体身份验证。

#### 2.1.1. 保密性 Confidentiality

   When most people think of security, they think of CONFIDENTIALITY. Confidentiality means that your data is kept secret from unintended listeners.  Usually, these listeners are simply eavesdroppers.  When an adversary taps your phone, it poses a risk to your confidentiality.

   当大多数人想到安全时，他们想到的是保密性。保密性意味着您的数据对无意的侦听者保密。通常，这些听众只是窃听者。当对手窃听你的电话时，你的隐私就会受到威胁。

   Obviously, if you have secrets, then you are probably concerned about others discovering them.  Thus, at the very least, you want to maintain confidentiality.  When you see spies in the movies go into the bathroom and turn on all the water to foil bugging, the property they're looking for is confidentiality.

   显然，如果你有秘密，那么你可能会担心其他人发现它们。因此，至少，你希望保持保密性。当你看到电影中的间谍走进浴室，打开所有的水龙头来屏蔽窃听器时，他们寻找的是机密。

#### 2.1.2. 数据完整性 Data Integrity

   The second primary goal is DATA INTEGRITY.  The basic idea here is that we want to make sure that the data we receive is the same data that the sender has sent.  In paper-based systems, some data integrity comes automatically.  When you receive a letter written in pen you can be fairly certain that no words have been removed by an attacker because pen marks are difficult to remove from paper. However, an attacker could have easily added some marks to the paper and completely changed the meaning of the message.  Similarly, it's easy to shorten the page to truncate the message.

   第二个主要目标是数据完整性。 这里的基本思想是我们要确保我们收到的数据与发送方发送的数据相同。 在基于纸张的系统中，一些数据完整性是自动出现的。 当您收到一封用钢笔写的信时，您可以相当确定攻击者没有删除任何文字，因为笔迹很难从纸上去除。 但是，攻击者可以很容易地在论文中添加一些标记并完全改变消息的含义。 同样，缩短页面以截断消息也很容易。

   On the other hand, in the electronic world, since all bits look alike, it's trivial to tamper with messages in transit.  You simply remove the message from the wire, copy out the parts you like, add whatever data you want, and generate a new message of your choosing, and the recipient is no wiser.  This is the moral equivalent of the attacker taking a letter you wrote, buying some new paper and recopying the message, changing it as he does it.  It's just a lot easier to do electronically since all bits look alike.

   另一方面，在电子世界中，由于所有比特看起来都很相似，因此在传输过程中对消息进行篡改是微不足道的。您只需从连线中删除消息，复制您喜欢的部分，添加您想要的任何数据，并生成您选择的新消息，而接收者并不知道。这相当于攻击者拿走你写的信，买一些新的纸张，重新复制信息，在他做的时候更改它。因为所有的位看起来都一样，所以用电子方式做要容易得多。

#### 2.1.3. 对等实体认证 Peer Entity authentication

   The third property we're concerned with is PEER ENTITY AUTHENTICATION.  What we mean by this is that we know that one of the endpoints in the communication is the one we intended.  Without peer entity authentication, it's very difficult to provide either confidentiality or data integrity.  For instance, if we receive a message from Alice, the property of data integrity doesn't do us much good unless we know that it was in fact sent by Alice and not the attacker.  Similarly, if we want to send a confidential message to Bob, it's not of much value to us if we're actually sending a confidential message to the attacker.

   我们关心的第三个属性是对等实体认证PEER ENTITY AUTHENTICATION。我们这么说的意思是，我们知道通信中的一个端点是我们想要的。没有对等实体身份验证，就很难提供保密性或数据完整性。例如，如果我们收到来自Alice的消息，数据完整性的属性对我们没有多大帮助，除非我们知道它实际上是由Alice而不是攻击者发送的。类似地，如果我们想要向Bob发送一条机密消息，那么如果我们实际上是在向攻击者发送一条机密消息，那么这条消息对我们来说也没有多大价值。

   Note that peer entity authentication can be provided asymmetrically. When you call someone on the phone, you can be fairly certain that you have the right person -- or at least that you got a person who's actually at the phone number you called.  On the other hand, if they don't have caller ID, then the receiver of a phone call has no idea who's calling them.  Calling someone on the phone is an example of recipient authentication, since you know who the recipient of the call is, but they don't know anything about the sender.

   注意，对等实体身份验证可以不对称地提供。当你打电话给某人时，你可以相当确定你找对了人——或者至少你找到了一个人，他实际上就在你打电话的那个号码旁边。另一方面，如果他们没有来电显示，那么电话的接收者就不知道是谁在给他们打电话。打电话给某人是接收方身份验证的一个例子，因为您知道呼叫的接收方是谁，但他们不知道发送方的任何信息。

   In messaging situations, you often wish to use peer entity authentication to establish the identity of the sender of a certain message.  In such contexts, this property is called DATA ORIGIN AUTHENTICATION.

   在消息传递情况下，您通常希望使用对等实体身份验证来确定特定消息的发送者的身份。在这种情况下，此属性称为数据源身份验证 DATA ORIGIN AUTHENTICATION。

### 2.2. 不可否认性 Non-Repudiation

   A system that provides endpoint authentication allows one party to be certain of the identity of someone with whom he is communicating. When the system provides data integrity a receiver can be sure of both the sender's identity and that he is receiving the data that that sender meant to send.  However, he cannot necessarily demonstrate this fact to a third party.  The ability to make this demonstration is called NON-REPUDIATION.

   提供端点身份验证的系统允许一方确定与他通信的人的身份。当系统提供数据完整性时，接收者可以确定发送者的身份以及他正在接收发送者打算发送的数据。然而，他不一定能向第三方证明这一事实。进行这种演示的能力称为不可否认性。

   There are many situations in which non-repudiation is desirable. Consider the situation in which two parties have signed a contract which one party wishes to unilaterally abrogate.  He might simply claim that he had never signed it in the first place.  Non-repudiation prevents him from doing so, thus protecting the counterparty.

   在许多情况下，不可否认性是值得做的。 考虑一下两方签署了一方希望单方面废除的合同的情况。 他可能会简单地声称他从一开始就没有签署过。 不可否认性阻止了他这样做，从而保护了交易对手。

   Unfortunately, non-repudiation can be very difficult to achieve in practice and naive approaches are generally inadequate.  Section 4.3 describes some of the difficulties, which generally stem from the fact that the interests of the two parties are not aligned -- one party wishes to prove something that the other party wishes to deny.

   不幸的是，在实践中很难实现不可否认性，而且幼稚的方法通常是不够的。 第 4.3 节描述了一些困难，这些困难通常源于两方的利益不一致——一方希望证明另一方希望否认的事情。

### 2.3. 系统安全 Systems Security

   In general, systems security is concerned with protecting one's machines and data.  The intent is that machines should be used only by authorized users and for the purposes that the owners intend. Furthermore, they should be available for those purposes.  Attackers should not be able to deprive legitimate users of resources.

   一般来说，系统安全与保护个人的机器和数据有关。其目的是，机器应该只被授权的用户使用，并用于所有者想要的目的。此外，应当为这些目的提供这些文件。攻击者不应该能够剥夺合法用户的资源。

#### 2.3.1. 未经授权的使用 Unauthorized Usage

   Most systems are not intended to be completely accessible to the public.  Rather, they are intended to be used only by certain authorized individuals.  Although many Internet services are available to all Internet users, even those servers generally offer a larger subset of services to specific users.  For instance, Web Servers often will serve data to any user, but restrict the ability to modify pages to specific users.  Such modifications by the general public would be UNAUTHORIZED USAGE.

   大多数系统并不打算完全对公众开放。 相反，它们仅供某些授权个人使用。 尽管所有 Internet 用户都可以使用许多 Internet 服务，但即使这些服务器通常也为特定用户提供更大的服务子集。 例如，Web 服务器通常会将数据提供给任何用户，但将修改页面的能力限制为特定用户。 公众的此类修改将是未经授权的使用。

#### 2.3.2. 不当使用 Inappropriate Usage

   Being an authorized user does not mean that you have free run of the system.  As we said above, some activities are restricted to authorized users, some to specific users, and some activities are generally forbidden to all but administrators.  Moreover, even activities which are in general permitted might be forbidden in some cases.  For instance, users may be permitted to send email but forbidden from sending files above a certain size, or files which contain viruses.  These are examples of INAPPROPRIATE USAGE.

   作为授权用户并不意味着你可以自由运行系统。如前所述，有些活动仅限于授权用户，有些活动仅限于特定用户，有些活动通常禁止除管理员以外的所有人进行。此外，即使是一般允许的活动，在某些情况下也可能被禁止。例如，用户可能被允许发送电子邮件，但禁止发送超过一定大小的文件，或包含病毒的文件。这些都是不当使用的例子。

#### 2.3.3. 拒绝服务 Denial of Service

   Recall that our third goal was that the system should be available to legitimate users.  A broad variety of attacks are possible which threaten such usage.  Such attacks are collectively referred to as DENIAL OF SERVICE attacks.  Denial of service attacks are often very easy to mount and difficult to stop.  Many such attacks are designed to consume machine resources, making it difficult or impossible to serve legitimate users.  Other attacks cause the target machine to crash, completely denying service to users.

   回想一下，我们的第三个目标是系统应该对合法用户可用。可能会有各种各样的攻击威胁到这种使用。这种攻击统称为拒绝服务攻击。拒绝服务攻击通常很容易发起，但很难停止。许多此类攻击的目的是消耗机器资源，使其难以或不可能为合法用户提供服务。其他攻击会导致目标机器崩溃，完全拒绝为用户提供服务。

## 3. 互联网威胁模型 The Internet Threat Model

   A THREAT MODEL describes the capabilities that an attacker is assumed to be able to deploy against a resource.  It should contain such information as the resources available to an attacker in terms of information, computing capability, and control of the system.  The purpose of a threat model is twofold.  First, we wish to identify the threats we are concerned with.  Second, we wish to rule some threats explicitly out of scope.  Nearly every security system is vulnerable to a sufficiently dedicated and resourceful attacker.

   威胁模型描述了假定攻击者能够针对资源部署的能力。 它应该包含攻击者在信息、计算能力和系统控制方面可用的资源等信息。 威胁模型的目的是双重的。 首先，我们希望确定我们所关注的威胁。 其次，我们希望明确排除一些超出范围的威胁。 几乎每个安全系统都容易受到足够专注和足智多谋的攻击者的攻击。

   The Internet environment has a fairly well understood threat model. In general, we assume that the end-systems engaging in a protocol exchange have not themselves been compromised.  Protecting against an attack when one of the end-systems has been compromised is extraordinarily difficult.  It is, however, possible to design protocols which minimize the extent of the damage done under these circumstances.

   互联网环境有一个相当容易理解的威胁模型。通常，我们假设参与协议交换的终端系统本身没有被破坏。当其中一个终端系统受到攻击时，防范攻击是非常困难的。然而，可以设计出在这些情况下将损害程度降到最低的协议。

   By contrast, we assume that the attacker has nearly complete control of the communications channel over which the end-systems communicate. This means that the attacker can read any PDU (Protocol Data Unit) on the network and undetectably remove, change, or inject forged packets onto the wire.  This includes being able to generate packets that appear to be from a trusted machine.  Thus, even if the end-system with which you wish to communicate is itself secure, the Internet environment provides no assurance that packets which claim to be from that system in fact are.

   相比之下，我们假设攻击者几乎完全控制了终端系统通信所通过的通信通道。这意味着攻击者可以读取网络上的任何协议数据单元PDU (Protocol Data Unit)，并在无法察觉的情况下删除、更改或注入伪造报文。这包括能够生成似乎来自可信机器的数据包。因此，即使您希望与之通信的终端系统本身是安全的，Internet环境也不能保证声称来自该系统的包实际上是安全的

   It's important to realize that the meaning of a PDU is different at different levels.  At the IP level, a PDU means an IP packet.  At the TCP level, it means a TCP segment.  At the application layer, it means some kind of application PDU.  For instance, at the level of email, it might either mean an RFC-822 message or a single SMTP command.  At the HTTP level, it might mean a request or response.

  重要的是要认识到PDU的含义在不同的级别上是不同的。在IP层，PDU是指IP报文。在TCP级别，它意味着一个TCP段。在应用层，它指的是某种应用程序PDU。例如，在电子邮件级别，它可能意味着RFC-822消息或单个SMTP命令。在HTTP级别，它可能意味着请求或响应。

### 3.1. 有限的威胁模型 Limited Threat Models

   As we've said, a resourceful and dedicated attacker can control the entire communications channel.  However, a large number of attacks can be mounted by an attacker with fewer resources.  A number of currently known attacks can be mounted by an attacker with limited control of the network.  For instance, password sniffing attacks can be mounted by an attacker who can only read arbitrary packets.  This is generally referred to as a PASSIVE ATTACK [INTAUTH].

   正如我们所说的，一个足智多谋、专心致志的攻击者可以控制整个通信通道。但是，攻击者可以使用较少的资源发起大量攻击。在网络控制有限的情况下，攻击者可以发起许多目前已知的攻击。例如，只能读取任意数据包的攻击者可以发起密码嗅探攻击。这通常被称为被动攻击[INTAUTH]。

   By contrast, Morris' sequence number guessing attack [SEQNUM] can be mounted by an attacker who can write but not read arbitrary packets. Any attack which requires the attacker to write to the network is known as an ACTIVE ATTACK.

   相比之下，Morris的序列号猜测攻击[SEQNUM]可以由能够写入但不能读取任意数据包的攻击者发起。任何需要攻击者写入网络的攻击都称为主动攻击。

   Thus, a useful way of organizing attacks is to divide them based on the capabilities required to mount the attack.  The rest of this section describes these categories and provides some examples of each category.

   因此，组织攻击的一种有用方法是根据发动攻击所需的能力来划分攻击。本节其余部分将介绍这些类别，并提供每个类别的一些示例。

### 3.2. 被动攻击 Passive Attacks

   In a passive attack, the attacker reads packets off the network but does not write them.  The simplest way to mount such an attack is to simply be on the same LAN as the victim.  On most common LAN configurations, including Ethernet, 802.3, and FDDI, any machine on the wire can read all traffic destined for any other machine on the same LAN.  Note that switching hubs make this sort of sniffing substantially more difficult, since traffic destined for a machine only goes to the network segment which that machine is on.

   被动攻击是指攻击者从网络中读取报文，但不写入报文。发起这种攻击的最简单方法是与受害者在同一局域网上。在大多数常见的局域网配置中，包括以太网、802.3和FDDI，线路上的任何机器都可以读取发送给同一局域网中任何其他机器的所有流量。注意，交换式集线器使这种嗅探变得非常困难，因为发送给一台机器的流量只会到达该机器所在的网段

   Similarly, an attacker who has control of a host in the communications path between two victim machines is able to mount a passive attack on their communications.  It is also possible to compromise the routing infrastructure to specifically arrange that traffic passes through a compromised machine.  This might involve an active attack on the routing infrastructure to facilitate a passive attack on a victim machine.

   类似地，在两台受害机器之间的通信路径中控制主机的攻击者能够对其通信发起被动攻击。也有可能破坏路由基础设施，专门安排流量通过受损机器。这可能涉及对路由基础设施的主动攻击，以促进对受害机器的被动攻击。

   Wireless communications channels deserve special consideration, especially with the recent and growing popularity of wireless-based LANs, such as those using 802.11.  Since the data is simply broadcast on well known radio frequencies, an attacker simply needs to be able to receive those transmissions.  Such channels are especially vulnerable to passive attacks.  Although many such channels include cryptographic protection, it is often of such poor quality as to be nearly useless [WEP].

   无线通信信道值得特别考虑，特别是随着最近越来越流行的无线局域网，例如那些使用802.11的局域网。由于数据只是在众所周知的无线电频率上广播，攻击者只需要能够接收这些传输。这种渠道特别容易受到被动攻击。尽管许多这样的通道包括加密保护，但通常质量很差，几乎毫无用处[WEP]。

   In general, the goal of a passive attack is to obtain information which the sender and receiver would prefer to remain private.  This private information may include credentials useful in the electronic world and/or passwords or credentials useful in the outside world, such as confidential business information.

   一般来说，被动攻击的目标是获取发送方和接收方希望保密的信息。这些私人信息可能包括在电子世界中有用的凭据和/或在外部世界中有用的密码或凭据，如机密商业信息。

#### 3.2.1. 违反保密规定 Confidentiality Violations

   The classic example of passive attack is sniffing some inherently private data off of the wire.  For instance, despite the wide availability of SSL, many credit card transactions still traverse the Internet in the clear.  An attacker could sniff such a message and recover the credit card number, which can then be used to make fraudulent transactions.  Moreover, confidential business information is routinely transmitted over the network in the clear in email.

   被动攻击的典型例子是从网络上嗅探一些固有的私有数据。例如，尽管SSL广泛可用，但许多信用卡交易仍然在互联网上进行。攻击者可以嗅出这样一条消息，并恢复信用卡号，然后利用该卡号进行欺诈交易。此外，机密商业信息通常通过网络以明文形式通过电子邮件传输。

#### 3.2.2. 密码嗅听 Password Sniffing

   Another example of a passive attack is PASSWORD SNIFFING.  Password sniffing is directed towards obtaining unauthorized use of resources. Many protocols, including [TELNET], [POP], and [NNTP] use a shared password to authenticate the client to the server.  Frequently, this password is transmitted from the client to the server in the clear over the communications channel.  An attacker who can read this traffic can therefore capture the password and REPLAY it.  In other words, the attacker can initiate a connection to the server and pose as the client and login using the captured password.

   另一个被动攻击的例子是密码嗅探。密码嗅探的目的是获取未经授权的资源使用。许多协议，包括[TELNET]， [POP]和[NNTP]使用一个共享的密码来验证客户端到服务器的身份。通常，这个密码通过通信通道以明文形式从客户端传输到服务器。能够读取此通信的攻击者因此可以捕获密码并重播它。换句话说，攻击者可以发起到服务器的连接，并伪装成客户端，使用捕获的密码登录。

   Note that although the login phase of the attack is active, the actual password capture phase is passive.  Moreover, unless the server checks the originating address of connections, the login phase does not require any special control of the network.

   请注意，虽然攻击的登录阶段是主动的，但实际的密码捕获阶段是被动的。此外，除非服务器检查连接的起始地址，否则登录阶段不需要对网络进行任何特殊的控制。

#### 3.2.3. 离线加密攻击 Offline Cryptographic Attacks

   Many cryptographic protocols are subject to OFFLINE ATTACKS.  In such a protocol, the attacker recovers data which has been processed using the victim's secret key and then mounts a cryptanalytic attack on that key.  Passwords make a particularly vulnerable target because they are typically low entropy.  A number of popular password-based challenge response protocols are vulnerable to DICTIONARY ATTACK. The attacker captures a challenge-response pair and then proceeds to try entries from a list of common words (such as a dictionary file) until he finds a password that produces the right response.

   许多加密协议都会受到离线攻击。在这种协议中，攻击者会恢复使用受害者密钥处理的数据，然后对该密钥发起密码分析攻击。密码是一个特别容易受到攻击的目标，因为它们通常是低熵的。许多流行的基于密码的质询响应协议容易受到字典攻击。攻击者捕获一个质询-响应对，然后继续尝试常用词列表（如字典文件）中的条目，直到找到一个产生正确响应的密码。

   A similar such attack can be mounted on a local network when NIS is used.  The Unix password is crypted using a one-way function, but tools exist to break such crypted passwords [KLEIN].  When NIS is used, the crypted password is transmitted over the local network and an attacker can thus sniff the password and attack it.

   当使用NIS时，类似的此类攻击可以在本地网络上发起。Unix密码是使用单向函数加密的，但有工具可以破解这种加密密码[KLEIN]。当使用NIS时，加密密码会通过本地网络传输，因此攻击者可以嗅探密码并对其进行攻击。

   Historically, it has also been possible to exploit small operating system security holes to recover the password file using an active attack.  These holes can then be bootstrapped into an actual account by using the aforementioned offline password recovery techniques. Thus we combine a low-level active attack with an offline passive attack.

   从历史上看，也有可能利用小的操作系统安全漏洞通过主动攻击来恢复密码文件。 然后可以使用上述离线密码恢复技术将这些漏洞引导到实际帐户中。 因此，我们将低级主动攻击与离线被动攻击结合起来。

### 3.3. 主动攻击 Active Attacks

   When an attack involves writing data to the network, we refer to this as an ACTIVE ATTACK.  When IP is used without IPsec, there is no authentication for the sender address.  As a consequence, it's straightforward for an attacker to create a packet with a source address of his choosing.  We'll refer to this as a SPOOFING ATTACK.

   当攻击涉及到向网络写入数据时，我们将其称为主动攻击。当采用IP方式而不采用IPsec方式时，对发送方地址不进行认证。因此，攻击者可以直接使用自己选择的源地址创建一个包。我们将此称为欺骗攻击。

   Under certain circumstances, such a packet may be screened out by the network.  For instance, many packet filtering firewalls screen out all packets with source addresses on the INTERNAL network that arrive on the EXTERNAL interface.  Note, however, that this provides no protection against an attacker who is inside the firewall.  In general, designers should assume that attackers can forge packets.

   在某些情况下，这样的数据包可能会被网络屏蔽掉。例如，许多包过滤防火墙会将所有到达EXTERNAL接口的源地址为INTERNAL网络的包过滤掉。但是，请注意，这不能保护防火墙内部的攻击者。通常，设计者应该假定攻击者可以伪造数据包。

   However, the ability to forge packets does not go hand in hand with the ability to receive arbitrary packets.  In fact, there are active attacks that involve being able to send forged packets but not receive the responses.  We'll refer to these as BLIND ATTACKS.

   然而，伪造数据包的能力并不等同于接收任意数据包的能力。事实上，有一些活跃的攻击包括能够发送伪造的数据包，但却没有收到响应。我们称之为盲目攻击。

   Note that not all active attacks require forging addresses.  For instance, the TCP SYN denial of service attack [TCPSYN] can be mounted successfully without disguising the sender's address. However, it is common practice to disguise one's address in order to conceal one's identity if an attack is discovered.

   请注意，并非所有主动攻击都需要伪造地址。 例如，TCP SYN 拒绝服务攻击 [TCPSYN] 可以在不伪装发送者地址的情况下成功挂载。 但是，通常的做法是伪装自己的地址，以便在发现攻击时隐藏自己的身份。

   Each protocol is susceptible to specific active attacks, but experience shows that a number of common patterns of attack can be adapted to any given protocol.  The next sections describe a number of these patterns and give specific examples of them as applied to known protocols.

   每个协议都容易受到特定的主动攻击，但经验表明，许多常见的攻击模式可以适应任何给定的协议。 接下来的部分描述了许多这些模式，并给出了应用于已知协议的具体示例。

#### 3.3.1. 重放攻击 Replay Attacks

   In a REPLAY ATTACK, the attacker records a sequence of messages off of the wire and plays them back to the party which originally received them.  Note that the attacker does not need to be able to understand the messages.  He merely needs to capture and retransmit them.

   在重放攻击中，攻击者从线路上记录一系列消息并将它们回放给最初接收它们的一方。 请注意，攻击者不需要能够理解这些消息。 他只需要捕获并重新传输它们。

   For example, consider the case where an S/MIME message is being used to request some service, such as a credit card purchase or a stock trade.  An attacker might wish to have the service executed twice, if only to inconvenience the victim.  He could capture the message and replay it, even though he can't read it, causing the transaction to be executed twice.

   例如，考虑使用 S/MIME 消息请求某些服务的情况，例如信用卡购买或股票交易。 攻击者可能希望服务执行两次，即使只是为了给受害者带来不便。 他可以捕获消息并重放它，即使他无法阅读它，从而导致事务执行两次。

#### 3.3.2. Message Insertion

   In a MESSAGE INSERTION attack, the attacker forges a message with some chosen set of properties and injects it into the network.  Often this message will have a forged source address in order to disguise the identity of the attacker.

   在消息插入攻击中，攻击者伪造具有某些选定属性集的消息并将其注入网络。 通常，此消息将具有伪造的源地址，以伪装攻击者的身份。

   For example, a denial-of-service attack can be mounted by inserting a series of spurious TCP SYN packets directed towards the target host. The target host responds with its own SYN and allocates kernel data structures for the new connection.  The attacker never completes the 3-way handshake, so the allocated connection endpoints just sit there taking up kernel memory.  Typical TCP stack implementations only allow some limited number of connections in this "half-open" state and when this limit is reached, no more connections can be initiated, even from legitimate hosts.  Note that this attack is a blind attack, since the attacker does not need to process the victim's SYNs.

   例如，可以通过插入一系列指向目标主机的虚假 TCP SYN 数据包来实施拒绝服务攻击。 目标主机用自己的 SYN 响应，并为新连接分配内核数据结构。 攻击者永远不会完成 3 次握手，因此分配的连接端点只是坐在那里占用内核内存。 典型的 TCP 堆栈实现仅允许在这种“半开”状态下进行一些有限数量的连接，当达到此限制时，即使是来自合法主机的连接也无法启动。 请注意，这种攻击是盲目的攻击，因为攻击者不需要处理受害者的 SYN。

#### 3.3.3. 消息删除 Message Deletion

   In a MESSAGE DELETION attack, the attacker removes a message from the wire.  Morris' sequence number guessing attack [SEQNUM] often requires a message deletion attack to be performed successfully.  In this blind attack, the host whose address is being forged will receive a spurious TCP SYN packet from the host being attacked. Receipt of this SYN packet generates a RST, which would tear the illegitimate connection down.  In order to prevent this host from sending a RST so that the attack can be carried out successfully, Morris describes flooding this host to create queue overflows such that the SYN packet is lost and thus never responded to.

   在消息删除攻击中，攻击者从线路中删除消息。 Morris 的序列号猜测攻击 [SEQNUM] 通常需要成功执行消息删除攻击。 在这种盲目攻击中，地址被伪造的主机会收到来自被攻击主机的虚假 TCP SYN 数据包。 接收到这个 SYN 数据包会生成一个 RST，这会破坏非法连接。 为了防止该主机发送 RST 以使攻击能够成功进行，Morris 描述了对该主机进行泛洪以创建队列溢出，从而使 SYN 数据包丢失，因此永远不会响应。

#### 3.3.4. 消息修改 Message Modification

   In a MESSAGE MODIFICATION attack, the attacker removes a message from the wire, modifies it, and reinjects it into the network.  This sort of attack is particularly useful if the attacker wants to send some of the data in the message but also wants to change some of it.

   在消息修改攻击中，攻击者从线路中删除消息，对其进行修改，然后将其重新注入网络。 如果攻击者想要发送消息中的一些数据但又想更改其中的一些数据，这种攻击特别有用。

   Consider the case where the attacker wants to attack an order for goods placed over the Internet.  He doesn't have the victim's credit card number so he waits for the victim to place the order and then replaces the delivery address (and possibly the goods description) with his own.  Note that this particular attack is known as a CUT- AND-PASTE attack since the attacker cuts the credit card number out of the original message and pastes it into the new message.

   考虑这样一种情况，攻击者想要攻击通过Internet发布的商品订单。他没有受害者的信用卡号码，所以他等待受害者下订单，然后用他自己的送货地址(可能还有货物描述)替换送货地址。请注意，这种特殊的攻击称为剪切和粘贴攻击，因为攻击者从原始消息中剪切出信用卡号并将其粘贴到新消息中。

   Another interesting example of a cut-and-paste attack is provided by [IPSPPROB].  If IPsec ESP is used without any MAC then it is possible for the attacker to read traffic encrypted for a victim on the same machine.  The attacker attaches an IP header corresponding to a port he controls onto the encrypted IP packet.  When the packet is received by the host it will automatically be decrypted and forwarded to the attacker's port.  Similar techniques can be used to mount a session hijacking attack.  Both of these attacks can be avoided by always using message authentication when you use encryption.  Note that this attack only works if (1) no MAC check is being used, since this attack generates damaged packets (2) a host-to-host SA is being used, since a user-to-user SA will result in an inconsistency between the port associated with the SA and the target port.  If the receiving machine is single-user than this attack is infeasible.

   [IPSPPROB]提供了另一个剪贴粘贴攻击的有趣示例。如果IPsec ESP在没有MAC的情况下使用，那么攻击者就有可能在同一台机器上读取受害者的加密流量。攻击者将一个与他控制的端口对应的IP报头附加到加密的IP包上。当数据包被主机接收时，它将自动被解密并转发到攻击者的端口。类似的技术也可以用于装载会话劫持攻击。这两种攻击都可以通过在使用加密时始终使用消息身份验证来避免。请注意，这种攻击只在以下情况下有效:(1)没有使用MAC检查，因为这种攻击会产生损坏的报文(2)正在使用主机到主机的SA，因为用户到用户的SA会导致与SA关联的端口和目标端口不一致。如果接收机器是单用户的，那么这种攻击是不可行的。

#### 3.3.5. 中间人攻击 Man-In-The-Middle

   A MAN-IN-THE-MIDDLE attack combines the above techniques in a special form: The attacker subverts the communication stream in order to pose as the sender to receiver and the receiver to the sender:

   中间人攻击攻击以一种特殊的形式结合了上述技术：攻击者破坏通信流，以伪装成发送者对接收者和接收者对发送者：

      What Alice and Bob think:
      Alice  <---------------------------------------------->  Bob

      What's happening:
      Alice  <---------------->  Attacker  <---------------->  Bob

   This differs fundamentally from the above forms of attack because it attacks the identity of the communicating parties, rather than the data stream itself.  Consequently, many techniques which provide integrity of the communications stream are insufficient to protect against man-in-the-middle attacks.

   这与上述形式的攻击有根本的不同，因为它攻击的是通信方的身份，而不是数据流本身。因此，许多提供通信流完整性的技术不足以防止中间人攻击。

   Man-in-the-middle attacks are possible whenever a protocol lacks PEER ENTITY AUTHENTICATION.  For instance, if an attacker can hijack the client TCP connection during the TCP handshake (perhaps by responding to the client's SYN before the server does), then the attacker can open another connection to the server and begin a man-in-the-middle attack.  It is also trivial to mount man-in-the-middle attacks on local networks via ARP spoofing -- the attacker forges an ARP with the victim's IP address and his own MAC address.  Tools to mount this sort of attack are readily available.

   只要协议缺少对等实体身份验证，中间人攻击就可能发生。 例如，如果攻击者可以在 TCP 握手期间劫持客户端 TCP 连接（可能通过在服务器之前响应客户端的 SYN），那么攻击者可以打开另一个到服务器的连接并开始中间人 攻击。 通过 ARP 欺骗在本地网络上发起中间人攻击也很简单——攻击者使用受害者的 IP 地址和他自己的 MAC 地址伪造一个 ARP。 进行此类攻击的工具很容易获得

   Note that it is only necessary to authenticate one side of the transaction in order to prevent man-in-the-middle attacks.  In such a situation the the peers can establish an association in which only one peer is authenticated.  In such a system, an attacker can initiate an association posing as the unauthenticated peer but cannot transmit or access data being sent on a legitimate connection.  This is an acceptable situation in contexts such as Web e-commerce where only the server needs to be authenticated (or the client is independently authenticated via some non-cryptographic mechanism such as a credit card number).

   请注意，只需对交易的一侧进行身份验证即可防止中间人攻击。 在这种情况下，对等点可以建立一个关联，其中只有一个对等点被认证。 在这样的系统中，攻击者可以冒充未经身份验证的对等方发起关联，但无法传输或访问在合法连接上发送的数据。 在 Web 电子商务等环境中，这是一种可接受的情况，其中仅需要对服务器进行身份验证（或者客户端通过某些非加密机制（例如信用卡号）进行独立身份验证）。

### 3.4. 拓扑问题 Topological Issues

   In practice, the assumption that it's equally easy for an attacker to read and generate all packets is false, since the Internet is not fully connected.  This has two primary implications.

   在实践中，攻击者读取和生成所有数据包同样容易的假设是错误的，因为 Internet 没有完全连接。 这有两个主要含义。

### 3.5. 路径上与路径外 On-path versus off-path

   In order for a datagram to be transmitted from one host to another, it generally must traverse some set of intermediate links and gateways.  Such gateways are naturally able to read, modify, or remove any datagram transmitted along that path.  This makes it much easier to mount a wide variety of attacks if you are on-path.

   为了将数据报从一台主机传输到另一台主机，它通常必须穿过一组中间链路和网关。这样的网关自然能够读取、修改或删除沿该路径传输的任何数据报。如果你在链路上，这会让你更容易发动各种各样的攻击。

   Off-path hosts can, of course, transmit arbitrary datagrams that appear to come from any hosts but cannot necessarily receive datagrams intended for other hosts.  Thus, if an attack depends on being able to receive data, off-path hosts must first subvert the topology in order to place themselves on-path.  This is by no means impossible but is not necessarily trivial.

   当然，非路径主机可以传输看似来自任何主机的任意数据报，但不一定接收到打算发送给其他主机的数据报。 因此，如果攻击依赖于能够接收数据，则非路径主机必须首先破坏拓扑以便将自己置于路径上。 这绝不是不可能的，但也不一定是微不足道的。

   Applications protocol designers MUST NOT assume that all attackers will be off-path.  Where possible, protocols SHOULD be designed to resist attacks from attackers who have complete control of the network.  However, designers are expected to give more weight to attacks which can be mounted by off-path attackers as well as on-path ones.

   应用程序协议设计者绝不能假设所有攻击者都会偏离路径。 在可能的情况下，协议应该被设计成能够抵抗完全控制网络的攻击者的攻击。 然而，预计设计人员会更加重视可以由路径外攻击者和路径上攻击者发起的攻击。

### 3.6. 本地链接 Link-local

   One specialized case of on-path is being on the same link.  In some situations, it's desirable to distinguish between hosts who are on the local network and those who are not.  The standard technique for this is verifying the IP TTL value [IP].  Since the TTL must be decremented by each forwarder, a protocol can demand that TTL be set to 255 and that all receivers verify the TTL.  A receiver then has some reason to believe that conforming packets are from the same link.  Note that this technique must be used with care in the presence of tunneling systems, since such systems may pass packets without decrementing TTL.

   路径上的一种特殊情况是在同一链路上。 在某些情况下，需要区分在本地网络上的主机和不在本地网络上的主机。 对此的标准技术是验证 IP TTL 值 [IP]。 由于每个转发器都必须递减 TTL，因此协议可以要求将 TTL 设置为 255，并且所有接收器都验证 TTL。 然后，接收者有理由相信符合要求的数据包来自同一链路。 请注意，在存在隧道系统的情况下必须小心使用此技术，因为此类系统可能会在不递减 TTL 的情况下传递数据包。

## 4. 常见问题 Common Issues

   Although each system's security requirements are unique, certain common requirements appear in a number of protocols.  Often, when naive protocol designers are faced with these requirements, they choose an obvious but insecure solution even though better solutions are available.  This section describes a number of issues seen in many protocols and the common pieces of security technology that may be useful in addressing them.

   尽管每个系统的安全需求都是独特的，但某些常见的需求出现在许多协议中。通常，当单纯的协议设计人员面对这些需求时，他们会选择一个明显但不安全的解决方案，即使有更好的解决方案。本节描述了许多协议中出现的一些问题，以及在解决这些问题时可能有用的常见安全技术。

### 4.1. 用户身份验证 User Authentication

   Essentially every system which wants to control access to its resources needs some way to authenticate users.  A nearly uncountable number of such mechanisms have been designed for this purpose.  The next several sections describe some of these techniques.

   实际上，每个想要控制对其资源的访问的系统都需要某种方式来验证用户。为这一目的设计的这种机制的数量几乎是不可数的。接下来的几节将介绍其中的一些技术。

#### 4.1.1. 用户名/密码 Username/Password

   The most common access control mechanism is simple USERNAME/PASSWORD The user provides a username and a reusable password to the host which he wishes to use.  This system is vulnerable to a simple passive attack where the attacker sniffs the password off the wire and then initiates a new session, presenting the password.  This threat can be mitigated by hosting the protocol over an encrypted connection such as TLS or IPSEC.  Unprotected (plaintext) username/password systems are not acceptable in IETF standards.

   最常见的访问控制机制是简单的用户名/密码。用户向希望使用的主机提供用户名和可重复使用的密码。该系统容易受到简单的被动攻击，攻击者会嗅出网络上的密码，然后启动一个新会话，并提供密码。通过在加密连接（如TLS或IPSEC）上托管协议，可以减轻这种威胁。IETF标准中不接受未受保护（明文）的用户名/密码系统。

#### 4.1.2. 挑战/应答和一次性密码 Challenge Response and One Time Passwords

   Systems which desire greater security than USERNAME/PASSWORD often employ either a ONE TIME PASSWORD [OTP] scheme or a CHALLENGE-RESPONSE.  In a one time password scheme, the user is provided with a list of passwords, which must be used in sequence, one time each.(Often these passwords are generated from some secret key so the user can simply compute the next password in the sequence.)  SecureID and DES Gold are variants of this scheme.  In a challenge-response scheme, the host and the user share some secret (which often is represented as a password).  In order to authenticate the user, the host presents the user with a (randomly generated) challenge.  The user computes some function based on the challenge and the secret and provides that to the host, which verifies it.  Often this computation is performed in a handheld device, such as a DES Gold card.

   需要比用户名/密码更高安全性的系统通常采用一次性密码[OTP]方案或挑战响应。在一次性密码方案中，向用户提供密码列表，必须按顺序使用，每次一次。（这些密码通常是从某个密钥生成的，因此用户可以简单地计算序列中的下一个密码。）SecureID和DES Gold是该方案的变体。在质询-响应方案中，主机和用户共享一些秘密（通常表示为密码）。为了对用户进行身份验证，主机向用户提供（随机生成的）质询。用户根据挑战和秘密计算一些函数，并将其提供给主机，由主机进行验证。这种计算通常在手持设备中进行，比如DES金卡。

   Both types of scheme provide protection against replay attack, but often still vulnerable to an OFFLINE KEYSEARCH ATTACK (a form of passive attack): As previously mentioned, often the one-time password or response is computed from a shared secret.  If the attacker knows the function being used, he can simply try all possible shared secrets until he finds one that produces the right output.  This is made easier if the shared secret is a password, in which case he can mount a DICTIONARY ATTACK -- meaning that he tries a list of common words (or strings) rather than just random strings.

   这两种类型的方案都提供了防止重放攻击的保护，但通常仍然容易受到脱机密钥搜索攻击（被动攻击的一种形式）：如前所述，一次性密码或响应通常是根据共享密钥计算的。如果攻击者知道正在使用的函数，他可以尝试所有可能的共享秘密，直到找到一个产生正确输出的秘密。如果共享秘密是密码，那么这就更容易了，在这种情况下，他可以发起字典攻击——这意味着他尝试一系列常用词（或字符串），而不仅仅是随机字符串。

   These systems are also often vulnerable to an active attack.  Unless communication security is provided for the entire session, the attacker can simply wait until authentication has been performed and hijack the connection.

   这些系统通常也容易受到主动攻击。除非为整个会话提供通信安全性，否则攻击者只需等待验证完成，即可劫持连接。

#### 4.1.3. 共享密钥 Shared Keys

   CHALLENGE-RESPONSE type systems can be made secure against dictionary attack by using randomly generated shared keys instead of user-generated passwords.  If the keys are sufficiently large then keysearch attacks become impractical.  This approach works best when the keys are configured into the end nodes rather than memorized and typed in by users, since users have trouble remembering sufficiently long keys.

   通过使用随机生成的共享密钥而不是用户生成的密码，挑战-响应型系统可以防止字典攻击。如果密钥足够大，则密钥搜索攻击变得不切实际。当密钥被配置到终端节点而不是由用户记忆和输入时，这种方法效果最好，因为用户很难记住足够长的密钥。

   Like password-based systems, shared key systems suffer from management problems.  Each pair of communicating parties must have their own agreed-upon key, which leads to there being a lot of keys.

   与基于密码的系统一样，共享密钥系统也存在管理问题。每一对通信方都必须拥有自己的约定密钥，这导致存在大量密钥。

#### 4.1.4. 密钥分发中心 Key Distribution Centers

   One approach to solving the large number of keys problem is to use an online "trusted third party" that mediates between the authenticating parties.  The trusted third party (generally called a a KEY DISTRIBUTION CENTER (KDC)) shares a symmetric key or password with each party in the system.  It first contacts the KDC which gives it a TICKET containing a randomly generated symmetric key encrypted under both peer's keys.  Since only the proper peers can decrypt the symmetric key the ticket can be used to establish a trusted association.  By far the most popular KDC system is Kerberos [KERBEROS].

   解决大量密钥问题的一种方法是使用在线的“可信第三方”，它在身份验证方之间进行中介。受信任的第三方(通常称为密钥分发中心(KDC))与系统中的每一方共享一个对称密钥或密码。它首先与KDC联系，KDC给它一个包含随机生成的对称密钥的TICKET，该密钥在对等方的密钥下加密。因为只有正确的对等体可以解密对称密钥，所以票证可以用来建立一个可信的关联。到目前为止最流行的KDC系统是Kerberos [Kerberos]。

#### 4.1.5. 证书 Certificates

   A simple approach is to have all users have CERTIFICATES [PKIX] which they then use to authenticate in some protocol-specific way, as in [TLS] or [S/MIME].  A certificate is a signed credential binding an entity's identity to its public key.  The signer of a certificate is a CERTIFICATE AUTHORITY (CA), whose certificate may itself be signed by some superior CA.  In order for this system to work, trust in one or more CAs must be established in an out-of-band fashion.  Such CAs are referred to as TRUSTED ROOTS or ROOT CAS.  The primary obstacle to this approach in client-server type systems is that it requires clients to have certificates, which can be a deployment problem.

   一种简单的方法是让所有用户都有证书[PKIX]，然后他们用某种特定协议的方式进行身份验证，比如[TLS]或[S/MIME]。证书是将实体的身份绑定到其公钥的签名凭证。证书的签名者是一个证书颁发机构(certificate AUTHORITY, CA)，其证书本身可以由某个上级CA签名。为了使该系统工作，必须以带外方式建立对一个或多个CA的信任。这样的ca称为受信任的根ca或根ca。在客户机-服务器类型的系统中，这种方法的主要障碍是它要求客户机具有证书，这可能是一个部署问题

#### 4.1.6. 一些不常见的系统 Some Uncommon Systems

   There are ways to do a better job than the schemes mentioned above, but they typically don't add much security unless communications security (at least message integrity) will be employed to secure the connection, because otherwise the attacker can merely hijack the connection after authentication has been performed.  A number of protocols ([EKE], [SPEKE], [SRP]) allow one to securely bootstrap a user's password into a shared key which can be used as input to a cryptographic protocol.  One major obstacle to the deployment of these protocols has been that their Intellectual Property status is extremely unclear.  Similarly, the user can authenticate using public key certificates (e.g., S-HTTP client authentication).  Typically these methods are used as part of a more complete security protocol.

   有一些方法比上述方案做得更好，但它们通常不会增加太多安全性，除非采用通信安全性（至少是消息完整性）来保护连接，否则攻击者只能在执行身份验证后劫持连接。许多协议（[EKE]、[SPEKE]、[SRP]）允许用户安全地将密码引导到共享密钥中，该密钥可以用作加密协议的输入。部署这些协议的一个主要障碍是，它们的知识产权状况极不清楚。类似地，用户可以使用公钥证书进行身份验证（例如，S-HTTP客户端身份验证）。通常，这些方法被用作更完整的安全协议的一部分。

#### 4.1.7. 主机身份验证 Host Authentication

   Host authentication presents a special problem.  Quite commonly, the addresses of services are presented using a DNS hostname, for instance as a URL [URL].  When requesting such a service, one has to ensure that the entity that one is talking to not only has a certificate but that that certificate corresponds to the expected identity of the server.  The important thing to have is a secure binding between the certificate and the expected hostname.

   主机身份验证是一个特殊的问题。通常，服务的地址是使用DNS主机名表示的，例如URL[URL]。在请求此类服务时，必须确保与之交谈的实体不仅拥有证书，而且该证书与服务器的预期标识相对应。重要的是在证书和预期主机名之间有一个安全绑定。

   For instance, it is usually not acceptable for the certificate to contain an identity in the form of an IP address if the request was for a given hostname.  This does not provide end-to-end security because the hostname-IP mapping is not secure unless secure name resolution [DNSSEC] is being used.  This is a particular problem when the hostname is presented at the application layer but the authentication is performed at some lower layer.

   例如，如果请求是针对给定主机名的，则证书通常不能以IP地址的形式包含标识。因为主机名IP映射不安全，这不提供端到端安全性，除非使用安全名称解析[DNSSEC]。当主机名在应用程序层显示，但身份验证在较低层执行时，这是一个特别的问题。

#### 4.2. 通用安全框架 Generic Security Frameworks

   Providing security functionality in a protocol can be difficult.  In addition to the problem of choosing authentication and key establishment mechanisms, one needs to integrate it into a protocol. One response to this problem (embodied in IPsec and TLS) is to create a lower-level security protocol and then insist that new protocols be run over that protocol.  Another approach that has recently become popular is to design generic application layer security frameworks. The idea is that you design a protocol that allows you to negotiate various security mechanisms in a pluggable fashion.  Application protocol designers then arrange to carry the security protocol PDUs in their application protocol.  Examples of such frameworks include GSS-API [GSS] and SASL [SASL].

   在协议中提供安全功能可能很困难。除了选择身份验证和密钥建立机制的问题之外，还需要将其集成到协议中。对这个问题的一种回应(体现在IPsec和TLS中)是创建一个较低级别的安全协议，然后坚持在该协议上运行新的协议。最近流行的另一种方法是设计通用的应用层安全框架。其思想是，设计一种协议，允许您以可插拔的方式协商各种安全机制。应用协议设计者然后安排在他们的应用协议中携带安全协议pdu。此类框架的例子包括GSS- api [GSS]和SASL [SASL]。

   The generic framework approach has a number of problems.  First, it is highly susceptible to DOWNGRADE ATTACKS.  In a downgrade attack, an active attacker tampers with the negotiation in order to force the parties to negotiate weaker protection than they otherwise would. It's possible to include an integrity check after the negotiation and key establishment have both completed, but the strength of this integrity check is necessarily limited to the weakest common algorithm.  This problem exists with any negotiation approach, but  Expand generic frameworks exacerbate it by encouraging the application protocol author to just specify the framework rather than think hard about the appropriate underlying mechanisms, particularly since the mechanisms can vary widely in the degree of security offered.

   通用框架方法存在许多问题。 首先，它很容易受到降级攻击。 在降级攻击中，主动攻击者篡改协商以迫使各方协商较弱的保护。 在协商和密钥建立都完成后，可以包括完整性检查，但这种完整性检查的强度必然限于最弱的通用算法。 这个问题存在于任何协商方法中，但 Expand 通用框架鼓励应用程序协议作者只指定框架而不是认真考虑适当的底层机制，特别是因为这些机制在提供的安全程度方面可能有很大差异，从而加剧了这个问题。

   Another problem is that it's not always obvious how the various security features in the framework interact with the application layer protocol.  For instance, SASL can be used merely as an authentication framework -- in which case the SASL exchange occurs but the rest of the connection is unprotected, but can also negotiate traffic protection, such as via GSS, as a mechanism.  Knowing under what circumstances traffic protection is optional and which it is required requires thinking about the threat model.

   另一个问题是，框架中的各种安全特性如何与应用层协议交互并不总是显而易见的。例如，SASL可以仅仅用作身份验证框架——在这种情况下，发生了SASL交换，但连接的其余部分不受保护，但还可以协商流量保护(如通过GSS)作为一种机制。要知道在什么情况下流量保护是可选的，哪些是必需的，需要考虑威胁模型。

   In general, authentication frameworks are most useful in situations where new protocols are being added to systems with pre-existing legacy authentication systems.  A framework allows new installations to provide better authentication while not forcing existing sites completely redo their legacy authentication systems.  When the security requirements of a system can be clearly identified and only a few forms of authentication are used, choosing a single security mechanism leads to greater simplicity and predictability.  In situations where a framework is to be used, designers SHOULD carefully examine the framework's options and specify only the mechanisms that are appropriate for their particular threat model. If a framework is necessary, designers SHOULD choose one of the established ones instead of designing their own.

   通常，在将新协议添加到具有预先存在的遗留身份验证系统的系统中的情况下，身份验证框架最有用。 框架允许新安装提供更好的身份验证，同时不强制现有站点完全重做其旧式身份验证系统。 当系统的安全要求可以清楚地识别并且只使用几种形式的身份验证时，选择单一的安全机制会导致更大的简单性和可预测性。 在要使用框架的情况下，设计人员应该仔细检查框架的选项并仅指定适合其特定威胁模型的机制。 如果需要一个框架，设计师应该选择一个已建立的框架，而不是自己设计。

### 4.3. 不可否认性 Non-repudiation

   The naive approach to non-repudiation is simply to use public-key digital signatures over the content.  The party who wishes to be bound (the SIGNING PARTY) digitally signs the message in question. The counterparty (the RELYING PARTY) can later point to the digital signature as proof that the signing party at one point agreed to the disputed message.  Unfortunately, this approach is insufficient.

   不可否认性的简单方法是在内容上使用公钥数字签名。希望被绑定的一方（签名方）对相关信息进行数字签名。交易对手（依赖方）可以稍后将数字签名作为证据，证明签名方在某一点上同意有争议的信息。不幸的是，这种方法是不够的。

   The easiest way for the signing party to repudiate the message is by claiming that his private key has been compromised and that some attacker (though not necessarily the relying party) signed the disputed message.  In order to defend against this attack the relying party needs to demonstrate that the signing party's key had not been compromised at the time of the signature.  This requires substantial infrastructure, including archival storage of certificate revocation information and timestamp servers to establish the time that the message was signed.

   签名方拒绝该消息的最简单方法是声称他的私钥已被泄露，并且一些攻击者（但不一定是依赖方）签署了有争议的消息。为了抵御这种攻击，依赖方需要证明签名方的密钥在签名时没有被泄露。这需要大量的基础设施，包括证书撤销信息的存档存储和时间戳服务器，以确定消息的签名时间。

   Additionally, the relying party might attempt to trick the signing party into signing one message while thinking he's signing another. This problem is particularly severe when the relying party controls the infrastructure that the signing party uses for signing, such as in kiosk situations.  In many such situations the signing party's key is kept on a smartcard but the message to be signed is displayed by the relying party.

   此外，依赖方可能会试图欺骗签署方签署一条消息，同时认为他正在签署另一条消息。 当依赖方控制签名方用于签名的基础设施时，这个问题尤其严重，例如在信息亭的情况下。 在许多此类情况下，签名方的密钥保存在智能卡上，但要签名的消息由依赖方显示。

   All of these complications make non-repudiation a difficult service to deploy in practice.

   所有这些复杂性使得不可否认性服务在实践中难以部署。

### 4.4. 授权与身份验证 Authorization vs. Authentication

   AUTHORIZATION is the process by which one determines whether an authenticated party has permission to access a particular resource or service.  Although tightly bound, it is important to realize that authentication and authorization are two separate mechanisms. Perhaps because of this tight coupling, authentication is sometimes mistakenly thought to imply authorization.  Authentication simply identifies a party, authorization defines whether they can perform a certain action.

   授权是一个过程，通过该过程可以确定经过身份验证的一方是否有权访问特定资源或服务。 尽管绑定紧密，但重要的是要认识到身份验证和授权是两个独立的机制。 也许由于这种紧密耦合，认证有时被错误地认为意味着授权。 身份验证只是识别一方，授权定义他们是否可以执行某个动作。

   Authorization necessarily relies on authentication, but authentication alone does not imply authorization.  Rather, before granting permission to perform an action, the authorization mechanism must be consulted to determine whether that action is permitted.

   授权必然依赖于身份验证，但仅身份验证并不意味着授权。 相反，在授予执行操作的权限之前，必须咨询授权机制以确定是否允许该操作。

#### 4.4.1. 访问控制列表 Access Control Lists

   One common form of authorization mechanism is an access control list (ACL), which lists users that are permitted access to a resource.Since assigning individual authorization permissions to each resource is tedious, resources are often hierarchically arranged so that the parent resource's ACL is inherited by child resources.  This allows administrators to set top level policies and override them when necessary.

   授权机制的一种常见形式是访问控制列表 (ACL)，它列出了被允许访问资源的用户。由于为每个资源分配单独的授权权限很繁琐，因此资源通常是分层排列的，以便继承父资源的 ACL 通过子资源。 这允许管理员设置顶级策略并在必要时覆盖它们。

#### 4.4.2. 基于证书的系统 Certificate Based Systems

   While the distinction between authentication and authorization is intuitive when using simple authentication mechanisms such as username and password (i.e., everyone understands the difference between the administrator account and a user account), with more complex authentication mechanisms the distinction is sometimes lost.

   虽然在使用简单的身份验证机制（例如用户名和密码）时，身份验证和授权之间的区别很直观（即每个人都了解管理员帐户和用户帐户之间的区别），但使用更复杂的身份验证机制时，有时会失去区别。

   With certificates, for instance, presenting a valid signature does not imply authorization.  The signature must be backed by a certificate chain that contains a trusted root, and that root must be trusted in the given context.  For instance, users who possess certificates issued by the Acme MIS CA may have different web access privileges than users who possess certificates issued by the Acme Accounting CA, even though both of these CAs are "trusted" by the Acme web server.

   例如，对于证书，提供有效的签名并不意味着授权。签名必须由包含受信任根的证书链支持，且该根在给定上下文中必须是受信任的。例如，拥有由Acme MIS CA颁发的证书的用户可能与拥有由Acme Accounting CA颁发的证书的用户拥有不同的web访问权限，即使这两个CA都受到Acme web服务器的“信任”。

   Mechanisms for enforcing these more complicated properties have not yet been completely explored.  One approach is simply to attach policies to ACLs describing what sorts of certificates are trusted. Another approach is to carry that information with the certificate, either as a certificate extension/attribute [PKIX, SPKI] or as a separate "Attribute Certificate".

   强化这些更复杂属性的机制尚未完全探索。一种方法是简单地将策略附加到AC（访问控制列表）L，描述哪些类型的证书是可信的。另一种方法是将该信息与证书一起携带，作为证书扩展/属性[PKIX，SPKI]或作为单独的“属性证书”。

### 4.5. 提供流量安全 Providing Traffic Security

   Securely designed protocols should provide some mechanism for securing (meaning integrity protecting, authenticating, and possibly encrypting) all sensitive traffic.  One approach is to secure the protocol itself, as in [DNSSEC], [S/MIME] or [S-HTTP].  Although this provides security which is most fitted to the protocol, it also requires considerable effort to get right.

   安全设计的协议应该提供一些机制来保护（即完整性保护、身份验证，以及可能的加密）所有敏感流量。一种方法是保护协议本身，如在[DNSSEC]、[S/MIME]或[S-HTTP]中。虽然这提供了最适合协议的安全性，但它也需要付出相当大的努力才能良好运行。

   Many protocols can be adequately secured using one of the available channel security systems.  We'll discuss the two most common, IPsec [AH, ESP] and [TLS].

   使用一个可用的通道安全系统可以充分保护许多协议。我们将讨论最常见的两种，IPsec[AH，ESP]和[TLS]。

#### 4.5.1. IPsec

   The IPsec protocols (specifically, AH and ESP) can provide transmission security for all traffic between two hosts.  The IPsec protocols support varying granularities of user identification, including for example "IP Subnet", "IP Address", "Fully Qualified Domain Name", and individual user ("Mailbox name").  These varying levels of identification are employed as inputs to access control facilities that are an intrinsic part of IPsec.  However, a given IPsec implementation might not support all identity types.  In particular, security gateways may not provide user-to-user authentication or have mechanisms to provide that authentication information to applications.

   IPsec 协议（特别是 AH 和 ESP）可以为两台主机之间的所有流量提供传输安全性。 IPsec 协议支持不同粒度的用户标识，包括例如“IP 子网”、“IP 地址”、“完全限定域名”和单个用户（“邮箱名称”）。 这些不同级别的标识被用作访问控制设施的输入，这些设施是 IPsec 的固有部分。 但是，给定的 IPsec 实现可能不支持所有身份类型。 特别是，安全网关可能不提供用户到用户的身份验证或具有向应用程序提供该身份验证信息的机制。

   When AH or ESP is used, the application programmer might not need to do anything (if AH or ESP has been enabled system-wide) or might need to make specific software changes (e.g., adding specific setsockopt() calls) -- depending on the AH or ESP implementation being used. Unfortunately, APIs for controlling IPsec implementations are not yet standardized.

   当使用AH或ESP时，应用程序程序员可能不需要做任何事情（如果AH或ESP已在系统范围内启用），或者可能需要进行特定的软件更改（例如，添加特定的setsockopt（）调用）——具体取决于所使用的AH或ESP实现。不幸的是，用于控制IPsec实现的API尚未标准化。

   The primary obstacle to using IPsec to secure other protocols is deployment.  The major use of IPsec at present is for VPN applications, especially for remote network access.  Without extremely tight coordination between security administrators and application developers, VPN usage is not well suited to providing security services for individual applications since it is difficult for such applications to determine what security services have in fact been provided.

   使用IPsec保护其他协议的主要障碍是部署。IPsec目前主要用于VPN应用，尤其是远程网络访问。如果安全管理员和应用程序开发人员之间没有非常紧密的协调，VPN的使用就不适合为单个应用程序提供安全服务，因为这些应用程序很难确定实际上提供了哪些安全服务。

   IPsec deployment in host-to-host environments has been slow.  Unlike application security systems such as TLS, adding IPsec to a non-IPsec system generally involves changing the operating system, either by modifying the kernel or installing new drivers.    This is a Expand substantially greater undertaking than simply installing a new application.  However, recent versions of a number of commodity operating systems include IPsec stacks, so deployment is becoming easier.

   IPsec在主机到主机环境中的部署一直很慢。与TLS等应用程序安全系统不同，将IPsec添加到非IPsec系统通常需要通过修改内核或安装新的驱动程序来更改操作系统。这比简单地安装一个新的应用程序要大得多。然而，许多商用操作系统的最新版本包括IPsec堆栈，因此部署变得更加容易。

   In environments where IPsec is sure to be available, it represents a viable option for protecting application communications traffic.  If the traffic to be protected is UDP, IPsec and application-specific object security are the only options.  However, designers MUST NOT assume that IPsec will be available.  A security policy for a generic application layer protocol SHOULD NOT simply state that IPsec must be used, unless there is some reason to believe that IPsec will be available in the intended deployment environment.  In environments where IPsec may not be available and the traffic is solely TCP, TLS is the method of choice, since the application developer can easily ensure its presence by including a TLS implementation in his package.

   在 IPsec 肯定可用的环境中，它代表了保护应用程序通信流量的可行选项。 如果要保护的流量是 UDP，则 IPsec 和特定于应用程序的对象安全是唯一的选项。 但是，设计人员不得假设 IPsec 将可用。 通用应用层协议的安全策略不应该简单地声明必须使用 IPsec，除非有理由相信 IPsec 将在预期的部署环境中可用。 在 IPsec 可能不可用且流量仅为 TCP 的环境中，TLS 是首选方法，因为应用程序开发人员可以通过在其包中包含 TLS 实现轻松确保其存在。

   In the special-case of IPv6, both AH and ESP are mandatory to implement.  Hence, it is reasonable to assume that AH/ESP are already available for IPv6-only protocols or IPv6-only deployments.  However, automatic key management (IKE) is not required to implement so protocol designers SHOULD not assume it will be present.  [USEIPSEC] provides quite a bit of guidance on when IPsec is a good choice.

   在IPv6的特殊情况下，AH和ESP都是必须实现的。因此，可以合理地假设AH/ESP已经可用于仅限IPv6的协议或仅限IPv6的部署。然而，不需要实现自动密钥管理（IKE），因此协议设计者不应该假设它会出现。[USEIPSEC]提供了很多关于何时IPsec是一个好选择的指导。

#### 4.5.2. SSL/TLS

   Currently, the most common approach is to use SSL or its successor TLS.  They provide channel security for a TCP connection at the application level.  That is, they run over TCP.  SSL implementations typically provide a Berkeley Sockets-like interface for easy programming.  The primary issue when designing a protocol solution around TLS is to differentiate between connections protected using TLS and those which are not.

   目前，最常见的方法是使用SSL或其后续TLS。它们在应用程序级别为TCP连接提供通道安全性。也就是说，它们通过TCP运行。SSL实现通常提供一个类似Berkeley socket的接口，便于编程。在围绕TLS设计协议解决方案时，主要问题是区分使用TLS保护的连接和不使用TLS保护的连接。

   The two primary approaches used have a separate well-known port for TLS connections (e.g., the HTTP over TLS port is 443) [HTTPTLS] or to have a mechanism for negotiating upward from the base protocol to TLS as in [UPGRADE] or [STARTTLS].  When an upward negotiation strategy is used, care must be taken to ensure that an attacker can not force a clear connection when both parties wish to use TLS.

   所使用的两种主要方法有一个单独的众所周知的TLS连接端口（例如，HTTP over TLS端口为443）[HTTPTLS]，或有一种机制，用于从基本协议向上协商TLS，如[UPGRADE]或[STARTTLS]中所述。当使用向上协商策略时，必须小心确保当双方都希望使用TLS时，攻击者无法强制建立清晰的连接。

   Note that TLS depends upon a reliable protocol such as TCP or SCTP. This produces two notable difficulties.  First, it cannot be used to secure datagram protocols that use UDP.  Second, TLS is susceptible to IP layer attacks that IPsec is not.  Typically, these attacks take some form of denial of service or connection assassination.  For instance, an attacker might forge a TCP RST to shut down SSL connections.  TLS has mechanisms to detect truncation attacks but these merely allow the victim to know he is being attacked and do not provide connection survivability in the face of such attacks.  By contrast, if IPsec were being used, such a forged RST could be rejected without affecting the TCP connection.  If forged RSTs or other such attacks on the TCP connection are a concern, then AH/ESP or the TCP MD5 option [TCPMD5] are the preferred choices.

   请注意，TLS 依赖于可靠的协议，例如 TCP 或 SCTP。 这产生了两个显着的困难。 首先，它不能用于保护使用 UDP 的数据报协议。 其次，TLS 容易受到 IPsec 不易受到的 IP 层攻击。 通常，这些攻击采取某种形式的拒绝服务或连接暗杀。 例如，攻击者可能伪造 TCP RST 来关闭 SSL 连接。 TLS 具有检测截断攻击的机制，但这些机制只是让受害者知道他正在受到攻击，并且在面对此类攻击时不提供连接生存能力。 相比之下，如果使用 IPsec，则可以拒绝这种伪造的 RST，而不会影响 TCP 连接。 如果担心对 TCP 连接的伪造 RST 或其他此类攻击，则 AH/ESP 或 TCP MD5 选项 [TCPMD5] 是首选。

##### 4.5.2.1. 虚拟主机 Virtual Hosts

   If the "separate ports" approach to TLS is used, then TLS will be negotiated before any application-layer traffic is sent.  This can cause a problem with protocols that use virtual hosts, such as [HTTP], since the server does not know which certificate to offer the client during the TLS handshake.  The TLS hostname extension [TLSEXT] can be used to solve this problem, although it is too new to have seen wide deployment.

   如果使用 TLS 的“分离端口”方法，则 TLS 将在发送任何应用层流量之前进行协商。 这可能会导致使用虚拟主机的协议出现问题，例如 [HTTP]，因为服务器不知道在 TLS 握手期间向客户端提供哪个证书。 TLS 主机名扩展 [TLSEXT] 可用于解决此问题，尽管它太新而无法广泛部署。

##### 4.5.2.2. 远程身份验证和 TLS Remote Authentication and TLS

   One difficulty with using TLS is that the server is authenticated via a certificate.  This can be inconvenient in environments where previously the only form of authentication was a password shared between client and server.  It's tempting to use TLS without an authenticated server (i.e., with anonymous DH or a self-signed RSA certificate) and then authenticate via some challenge-response mechanism such as SASL with CRAM-MD5.

   使用TLS的一个困难是通过证书对服务器进行身份验证。在以前唯一的身份验证形式是客户机和服务器之间共享密码的环境中，这可能很不方便。很容易使用没有经过身份验证的服务器的TLS(即，使用匿名DH或自签名RSA证书)，然后通过一些挑战-响应机制进行身份验证，例如使用CRAM-MD5的SASL。

   Unfortunately, this composition of SASL and TLS is less strong than one would expect.  It's easy for an active attacker to hijack this connection.  The client man-in-the-middles the SSL connection (remember we're not authenticating the server, which is what ordinarily prevents this attack) and then simply proxies the SASL handshake.  From then on, it's as if the connection were in the clear, at least as far as that attacker is concerned.  In order to prevent this attack, the client needs to verify the server's certificate.

   不幸的是，SASL和TLS的这种组合并不像人们预期的那样强大。活跃的攻击者很容易劫持这个连接。客户机在中间连接SSL连接(记住，我们不验证服务器，这通常是防止这种攻击的方法)，然后简单地代理SASL握手。从那时起，似乎连接是透明的，至少对攻击者来说是这样的。为了防止这种攻击，客户端需要验证服务器的证书。

   However, if the server is authenticated, challenge-response becomes less desirable.  If you already have a hardened channel then simple passwords are fine.  In fact, they're arguably superior to challenge-response since they do not require that the password be stored in the clear on the server.  Thus, compromise of the key file with challenge-response systems is more serious than if simple passwords were used.

   但是，如果服务器经过身份验证，挑战-响应就变得不那么理想了。 如果您已经有一个强化通道，那么简单的密码就可以了。 事实上，它们可以说优于挑战-响应，因为它们不需要将密码以明文形式存储在服务器上。 因此，使用挑战-响应系统对密钥文件的破坏比使用简单密码的情况更为严重。

  > *Note that if the client has a certificate then SSL-based client Expand authentication can be used.  To make this easier, SASL provides the EXTERNAL mechanism, whereby the SASL client can tell the server "examine the outer channel for my identity".  Obviously, this is not subject to the layering attacks described above.<br/>请注意，如果客户端有证书，则可以使用基于SSL的客户端扩展身份验证。为了简化这一过程，SASL提供了外部机制，SASL客户端可以通过该机制告诉服务器“检查外部通道以获取我的身份”。显然，这不受上述分层攻击的影响。*

#### 4.5.3. 远程登录 Remote Login

   In some special cases it may be worth providing channel-level security directly in the application rather than using IPSEC or SSL/TLS.  One such case is remote terminal security.  Characters are typically delivered from client to server one character at a time. Since SSL/TLS and AH/ESP authenticate and encrypt every packet, this can mean a data expansion of 20-fold.  The telnet encryption option [ENCOPT] prevents this expansion by foregoing message integrity.

   在某些特殊情况下，可以在应用程序中直接提供通道级安全性，而不是使用IPSEC或SSL/TLS。远程终端安全就是这样一种情况。字符通常一次一个字符从客户端传递到服务器。由于SSL/TLS和AH/ESP对每个数据包进行认证和加密，这可能意味着数据扩展20倍。telnet加密选项[ENCOPT]通过前面的消息完整性来阻止这种扩展。

   When using remote terminal service, it's often desirable to securely perform other sorts of communications services.  In addition to providing remote login, SSH [SSH] also provides secure port forwarding for arbitrary TCP ports, thus allowing users run arbitrary TCP-based applications over the SSH channel.  Note that SSH Port Forwarding can be security issue if it is used improperly to circumvent firewall and improperly expose insecure internal applications to the outside world.

   在使用远程终端服务时，通常需要安全执行其他类型的通信服务。除了提供远程登录，SSH [SSH]还提供了任意TCP端口的安全端口转发，从而允许用户在SSH通道上运行任意基于TCP的应用程序。请注意，如果不恰当地使用SSH端口转发绕过防火墙，并不恰当地将不安全的内部应用程序暴露给外部世界，那么它可能会带来安全问题。

### 4.6. 拒绝服务攻击及对策 Denial of Service Attacks and Countermeasures

   Denial of service attacks are all too frequently viewed as an fact of life.  One problem is that an attacker can often choose from one of many denial of service attacks to inflict upon a victim, and because most of these attacks cannot be thwarted, common wisdom frequently assumes that there is no point protecting against one kind of denial of service attack when there are many other denial of service attacks that are possible but that cannot be prevented.

   拒绝服务攻击经常被视为现实。一个问题是，攻击者通常可以从众多拒绝服务攻击中选择一种攻击受害者，而且由于这些攻击中的大多数都无法阻止，常识通常认为，当存在许多其他可能但无法预防的拒绝服务攻击时，防范一种拒绝服务攻击是没有意义的。

   However, not all denial of service attacks are equal and more importantly, it is possible to design protocols so that denial of service attacks are made more difficult, if not impractical.  Recent SYN flood attacks [TCPSYN] demonstrate both of these properties: SYN flood attacks are so easy, anonymous, and effective that they are more attractive to attackers than other attacks; and because the design of TCP enables this attack.

   然而，并非所有的拒绝服务攻击都是相当的，更重要的是，可以设计协议，使拒绝服务攻击变得更加困难，如果不是不切实际的话。 最近的 SYN 泛洪攻击 [TCPSYN] 证明了这两个属性： SYN 泛洪攻击非常简单、匿名且有效，因此它们比其他攻击更能吸引攻击者； 并且因为 TCP 的设计使这种攻击成为可能。

   Because complete DoS protection is so difficult, security against DoS must be dealt with pragmatically.  In particular, some attacks which would be desirable to defend against cannot be defended against economically.  The goal should be to manage risk by defending against attacks with sufficiently high ratios of severity to cost of defense. Both severity of attack and cost of defense change as technology changes and therefore so does the set of attacks which should be defended against.

   由于完全的DoS保护是非常困难的，所以针对DoS的安全必须务实地处理。 特别是，一些需要防御的攻击不能被经济地防御。 目标应该是通过防御具有足够高的严重性和防御成本比率的攻击来管理风险。攻击的严重性和防御的成本都会随着技术的变化而变化，因此，应该防御的攻击的集合也会变化。

   Authors of internet standards MUST describe which denial of service attacks their protocol is susceptible to.  This description MUST include the reasons it was either unreasonable or out of scope to attempt to avoid these denial of service attacks.

   因特网标准的作者必须描述他们的协议容易受到哪些拒绝服务攻击。此描述必须包括试图避免这些拒绝服务攻击是不合理的或超出范围的原因。

#### 4.6.1. 盲目拒绝服务 Blind Denial of Service

   BLIND denial of service attacks are particularly pernicious.  With a blind attack the attacker has a significant advantage.  If the attacker must be able to receive traffic from the victim, then he must either subvert the routing fabric or use his own IP address. Either provides an opportunity for the victim to track the attacker and/or filter out his traffic.  With a blind attack the attacker can use forged IP addresses, making it extremely difficult for the victim to filter out his packets.  The TCP SYN flood attack is an example of a blind attack.  Designers should make every attempt possible to prevent blind denial of service attacks.

   盲目的拒绝服务攻击是特别有害的。 在盲目攻击中，攻击者有一个显著的优势。 如果攻击者必须能够接收来自受害者的流量，那么他必须颠覆路由结构或使用自己的IP地址。这两种方式都为受害者提供了追踪攻击者和/或过滤掉其流量的机会。 在盲目攻击中，攻击者可以使用伪造的IP地址，使受害者极难过滤掉他的数据包。 TCP SYN洪水攻击就是一个盲目攻击的例子。 设计师应该尽一切可能防止盲目拒绝服务攻击。

#### 4.6.2. 分布式拒绝服务 Distributed Denial of Service

   Even more dangerous are DISTRIBUTED denial of service attacks (DDoS)[DDOS].  In a DDoS the attacker arranges for a number of machines to attack the target machine simultaneously.  Usually this is accomplished by infecting a large number of machines with a program that allows remote initiation of attacks.  The machines actually performing the attack are called ZOMBIEs and are likely owned by unsuspecting third parties in an entirely different location from the true attacker.  DDoS attacks can be very hard to counter because the zombies often appear to be making legitimate protocol requests and simply crowd out the real users.  DDoS attacks can be difficult to thwart, but protocol designers are expected to be cognizant of these forms of attack while designing protocols.

   更危险的是分布式拒绝服务攻击(DDoS)[DDoS]。在DDoS攻击中，攻击者安排多台机器同时攻击目标机器。这通常是通过一个允许远程发起攻击的程序感染大量机器来实现的。实际上执行攻击的机器被称为僵尸，它们很可能被位于与真正攻击者完全不同位置的不知情的第三方所拥有。DDoS攻击很难反击，因为僵尸通常会发出合法的协议请求，简单地挤出真正的用户。DDoS攻击很难被阻止，但是协议设计者在设计协议时应该意识到这些形式的攻击。

#### 4.6.3. 避免拒绝服务 Avoiding Denial of Service

   There are two common approaches to making denial of service attacks more difficult:

   有两种常见的方法可以阻碍拒绝服务攻击:

##### 4.6.3.1. 让攻击者比你做更多的工作 Make your attacker do more work than you do

   If an attacker consumes more of his resources than yours when launching an attack, attackers with fewer resources than you will be unable to launch effective attacks.  One common technique is to require the attacker perform a time-intensive operation, such as a cryptographic operation.  Note that an attacker can still mount a denial of service attack if he can muster substantially sufficient CPU power.  For instance, this technique would not stop the distributed attacks described in [TCPSYN].

   如果攻击者在发动攻击时消耗的资源比你的多，那么资源比你少的攻击者就无法发动有效的攻击。 一种常见的技术是要求攻击者执行一个时间密集型的操作，如加密操作。 请注意，如果攻击者能够聚集足够的CPU能力，他仍然可以发动拒绝服务攻击。 例如，这种技术不能阻止[TCPSYN]中描述的分布式攻击。

##### 4.6.3.2. 让你的攻击者证明他们可以从你那里接收数据 Make your attacker prove they can receive data from you

   A blind attack can be subverted by forcing the attacker to prove that they can can receive data from the victim.  A common technique is to require that the attacker reply using information that was gained earlier in the message exchange.  If this countermeasure is used, the attacker must either use his own address (making him easy to track) or to forge an address which will be routed back along a path that traverses the host from which the attack is being launched.

   可以通过迫使攻击者证明他们可以从受害者那里接收数据来破坏盲攻击。一种常见的技术是要求攻击者使用在消息交换中早先获得的信息进行应答。如果使用此对策，攻击者必须使用自己的地址(使其易于跟踪)或伪造一个地址，该地址将沿着攻击发起的主机的路径被路由回来。

   Hosts on small subnets are thus useless to the attacker (at least in the context of a spoofing attack) because the attack can be traced back to a subnet (which should be sufficient for locating the attacker) so that anti-attack measures can be put into place (for instance, a boundary router can be configured to drop all traffic from that subnet).  A common technique is to require that the attacker reply using information that was gained earlier in the message exchange.

  因此，小子网的主机对攻击者来说是无用的（至少在欺骗攻击的情况下），因为攻击可以追溯到一个子网（这应该足以定位攻击者），这样就可以采取反攻击措施（例如，可以配置一个边界路由器，放弃来自该子网的所有流量）。 一种常见的技术是要求攻击者使用在信息交流中较早获得的信息进行回复。

#### 4.6.4. 例子：TCP SYN 洪范 Example: TCP SYN Floods

   TCP/IP is vulnerable to SYN flood attacks (which are described in section 3.3.2) because of the design of the 3-way handshake.  First, an attacker can force a victim to consume significant resources (in this case, memory) by sending a single packet.  Second, because the attacker can perform this action without ever having received data from the victim, the attack can be performed anonymously (and therefore using a large number of forged source addresses).

   由于三次握手的设计，TCP/IP很容易受到SYN洪流的攻击（这在3.3.2节中有描述）。 首先，攻击者可以通过发送一个数据包迫使受害者消耗大量的资源（在这里是指内存）。 其次，由于攻击者可以在没有收到受害者的数据的情况下执行这一行动，攻击可以匿名进行（因此使用大量的伪造源地址）。

####4.6.5. 例子：Photuris Example: Photuris

   [PHOTURIS] specifies an anti-clogging mechanism that prevents attacks on Photuris that resemble the SYN flood attack.  Photuris employs a time-variant secret to generate a "cookie" which is returned to the attacker.  This cookie must be returned in subsequent messages for the exchange to progress.  The interesting feature is that this cookie can be regenerated by the victim later in the exchange, and thus no state need be retained by the victim until after the attacker has proven that he can receive packets from the victim.

   [PHOTURIS]是一种防阻塞机制，用于防止类似SYN flood攻击的PHOTURIS攻击。Photuris使用了一个时变秘密来生成一个“cookie”，然后返回给攻击者。此cookie必须在后续消息中返回，以便交换继续进行。有趣的是，这个cookie可以在随后的交换中由受害者重新生成，因此在攻击者证明他可以接收到来自受害者的数据包之前，受害者不需要保留任何状态。

### 4.7. 对象安全与通道安全 Object vs. Channel Security

   It's useful to make the conceptual distinction between object security and channel security.  Object security refers to security measures which apply to entire data objects.  Channel security measures provide a secure channel over which objects may be carried transparently but the channel has no special knowledge about object boundaries.

   在对象安全性和通道安全性之间进行概念上的区分是很有用的。对象安全性是指应用于整个数据对象的安全措施。通道安全措施提供了一个安全通道，可以透明地传输对象，但通道对对象边界没有特殊的了解。

   Consider the case of an email message.  When it's carried over an IPSEC or TLS secured connection, the message is protected during transmission.  However, it is unprotected in the receiver's mailbox, and in intermediate spool files along the way.  Moreover, since mail servers generally run as a daemon, not a user, authentication of messages generally merely means authentication of the daemon not the user.  Finally, since mail transport is hop-by-hop, even if the user authenticates to the first hop relay the authentication can't be safely verified by the receiver.

   以电子邮件消息为例。当它通过IPSEC或TLS安全连接承载时，消息在传输过程中受到保护。但是，它在接收方的邮箱和中间的spool文件中是不受保护的。此外，由于邮件服务器通常作为守护进程而不是用户运行，消息的身份验证通常只意味着对守护进程而不是用户的身份验证。最后，由于邮件传输是逐跳的，即使用户对第一跳中继进行了身份验证，身份验证也不能由接收方进行安全验证。

   By contrast, when an email message is protected with S/MIME or OpenPGP, the entire message is encrypted and integrity protected until it is examined and decrypted by the recipient.  It also provides strong authentication of the actual sender, as opposed to the machine the message came from.  This is object security. Moreover, the receiver can prove the signed message's authenticity to a third party.

   相比之下，当电子邮件被S/MIME或OpenPGP保护时，直到被收件人检查和解密前，整个信息被加密并受到完整性保护。 它还提供了对实际发件人的强有力的认证，而不是对信息来源的机器。 这就是对象安全。此外，接收者可以向第三方证明签名信息的真实性。

   Note that the difference between object and channel security is a matter of perspective.  Object security at one layer of the protocol stack often looks like channel security at the next layer up.  So, from the perspective of the IP layer, each packet looks like an individually secured object.  But from the perspective of a web client, IPSEC just provides a secure channel.

   请注意，对象安全和通道安全之间的区别是一个视角问题。 在协议栈的某一层的对象安全往往看起来像下一层的通道安全。 因此，从IP层的角度来看，每个数据包看起来都是一个单独的安全对象。 但从网络客户的角度来看，IPSEC只是提供了一个安全通道。

   The distinction isn't always clear-cut.  For example, S-HTTP provides object level security for a single HTTP transaction, but a web page typically consists of multiple HTTP transactions (the base page and numerous inline images).  Thus, from the perspective of the total web page, this looks rather more like channel security.  Object security for a web page would consist of security for the transitive closure of the page and all its embedded content as a single unit.

   这种区别并不总是一目了然。 例如，S-HTTP为单一的HTTP事务提供对象级别的安全，但一个网页通常由多个HTTP事务组成（基本页面和许多内联图像）。 因此，从整个网页的角度来看，这看起来更像是渠道安全。 网页的对象安全将包括对网页及其所有嵌入内容作为一个单元的传递闭包的安全。

### 4.8. 防火墙与网络拓扑 Firewalls and Network Topology

   It's common security practice in modern networks to partition the network into external and internal networks using a firewall.  The internal network is then assumed to be secure and only limited security measures are used there.  The internal portion of such a network is often called a WALLED GARDEN.

   现代网络中常见的安全实践是使用防火墙将网络划分为外部和内部网络。然后假设内部网络是安全的，只使用有限的安全措施。这种网络的内部部分通常被称为 “ 有围墙的花园 ” 。

   Internet protocol designers cannot safely assume that their protocols will be deployed in such an environment, for three reasons.  First, protocols which were originally designed to be deployed in closed environments often are later deployed on the Internet, thus creating serious vulnerabilities. Second, networks which appear to be topologically disconnected may not be.  One reason may be that the network has been reconfigured to allow access by the outside world.  Moreover, firewalls are increasingly passing generic application layer protocols such as [SOAP] or [HTTP].  Network protocols which are based on these generic protocols cannot in general assume that a firewall will protect them. Finally, one of the most serious security threats to systems is from insiders, not outsiders.  Since insiders by definition have access to the internal network, topological protections such as firewalls will not protect them.

   Internet协议设计者不能想当然地认为他们的协议将部署在这样的环境中，原因有三。首先，最初设计用于在封闭环境中部署的协议后来常常部署在Internet上，从而产生严重的漏洞。第二，在拓扑结构上看起来是断开的网络可能并非如此。一个原因可能是网络已被重新配置，以允许外部世界访问。此外，防火墙正在越来越多地传递通用的应用层协议，如[SOAP]或[HTTP]。基于这些通用协议的网络协议通常不能假定防火墙会保护它们。最后，系统最严重的安全威胁之一来自内部人员，而不是外部人员。由于内部人员根据定义可以访问内部网络，因此诸如防火墙之类的拓扑保护不会保护他们。

## 5. 编写安全注意事项部分 Writing Security Considerations Sections

   While it is not a requirement that any given protocol or system be immune to all forms of attack, it is still necessary for authors to consider as many forms as possible.  Part of the purpose of the Security Considerations section Expand is to explain what attacks are in and out of scope and what countermeasures can be applied to defend against them.

   虽然并不要求任何给定的协议或系统对所有形式的攻击都免疫，但作者仍然需要考虑尽可能多的形式。扩展安全考虑一节的目的之一是解释哪些攻击是范围内的，哪些攻击是范围外的，以及可以应用哪些对策来防范这些攻击。

   There should be a clear description of the kinds of threats on the described protocol or technology.  This should be approached as an effort to perform "due diligence" in describing all known or foreseeable risks and threats to potential implementers and users.

   应该对所描述的协议或技术的威胁种类进行明确描述。 这应该作为一种努力，在描述所有已知或可预见的风险和威胁时，对潜在的实施者和用户进行 "尽职调查"。

   Authors MUST describe

   作者必须说明

      1.   which attacks are out of scope (and why!)
           哪些攻击不在范围内（以及为什么！）？
      2.   which attacks are in-scope
           哪些攻击是在范围内的
        2.1  and the protocol is susceptible to
             并且该协议容易受到哪些些攻击
        2.2  and the protocol protects against
             并且该协议可以防止哪些攻击

   At least the following forms of attack MUST be considered: eavesdropping, replay, message insertion, deletion, modification, and man-in-the-middle.  Potential denial of service attacks MUST be identified as well.  If the protocol incorporates cryptographic protection mechanisms, it should be clearly indicated which portions of the data are protected and what the protections are (i.e., integrity only, confidentiality, and/or endpoint authentication, etc.).  Some indication should also be given to what sorts of attacks the cryptographic protection is susceptible.  Data which should be held secret (keying material, random seeds, etc.) should be clearly labeled.

   至少必须考虑以下形式的攻击：窃听、重放、信息插入、删除、修改和中间人。 潜在的拒绝服务攻击也必须被确认。 如果协议采用了加密保护机制，应明确指出数据的哪些部分受到保护，保护的内容是什么（即仅完整性、保密性和/或端点认证等）。 还应说明加密保护容易受到哪些类型的攻击。 应该保密的数据（密钥材料、随机种子等）应该被清楚地标明。

   If the technology involves authentication, particularly user-host authentication, the security of the authentication method MUST be clearly specified.  That is, authors MUST document the assumptions that the security of this authentication method is predicated upon. For instance, in the case of the UNIX username/password login method, a statement to the effect of:

   如果该技术涉及认证，特别是用户-主机认证，则必须明确规定认证方法的安全性。 也就是说，作者必须记录该认证方法的安全性所依据的假设。例如，在UNIX的用户名/密码登录方法的情况下，大意如下的声明。

   > *Authentication in the system is secure only to the extent that it is difficult to guess or obtain a ASCII password that is a maximum of 8 characters long.  These passwords can be obtained by sniffing telnet sessions or by running the 'crack' program using the contents of the /etc/passwd file.  Attempts to protect against on-line password guessing by (1) disconnecting after several unsuccessful login attempts and (2) waiting between successive password prompts is effective only to the extent that attackers  are impatient.<br/>
   系统中的验证仅在难以猜测或获得最长 8 个字符的 ASCII 密码的范围内是安全的。 可以通过嗅探 telnet 会话或使用 /etc/passwd 文件的内容运行“破解”程序来获得这些密码。 通过 (1) 在几次不成功的登录尝试后断开连接和 (2) 在连续的密码提示之间等待来防止在线密码猜测的尝试仅在攻击者不耐烦的情况下才有效。<br/>
   Because the /etc/passwd file maps usernames to user ids, groups, etc. it must be world readable.  In order to permit this usage but make running crack more difficult, the file is often split into /etc/passwd and a 'shadow' password file.  The shadow file is not world readable and contains the encrypted password.  The regular /etc/passwd file contains a dummy password in its place.<br/>
   因为 /etc/passwd 文件将用户名映射到用户 ID、组等，所以它必须是全局可读的。 为了允许这种用法但使运行破解更加困难，该文件通常分为 /etc/passwd 和一个“影子”密码文件。 影子文件不是全局可读的，并且包含加密的密码。 常规 /etc/passwd 文件在其位置包含一个虚拟密码。 *

  It is insufficient to simply state that one's protocol should be run over some lower layer security protocol.  If a system relies upon lower layer security services for security, the protections those services are expected to provide MUST be clearly specified.  In addition, the resultant properties of the combined system need to be specified.

  简单地声明一个协议应该在一些较低层的安全协议上运行是不够的。 如果一个系统依赖于较低层的安全服务来保证安全，那么这些服务应该提供的保护必须明确规定。 此外，需要指定组合系统的结果属性。

   > *Note: In general, the IESG will not approve standards track protocols which do not provide for strong authentication, either internal to the protocol or through tight binding to a lower layer security protocol.
   <br/>注意：一般来说，IESG 不会批准不提供强身份验证的标准跟踪协议，无论是在协议内部还是通过与较低层安全协议的紧密绑定。*

   The threat environment addressed by the Security Considerations section MUST at a minimum include deployment across the global Internet across multiple administrative boundaries without assuming that firewalls are in place, even if only to provide justification for why such consideration is out of scope for the protocol.  It is not acceptable to only discuss threats applicable to LANs and ignore the broader threat environment.  All IETF standards-track protocols are considered likely to have deployment in the global Internet.  In some cases, there might be an Applicability Statement discouraging use of a technology or protocol in a particular environment. Nonetheless, the security issues of broader deployment should be discussed in the document.

   安全考虑部分所讨论的威胁环境至少必须包括跨多个管理边界的跨全球Internet的部署，而无需假设防火墙已经就绪，即使只是为了说明为什么这种考虑超出了协议的范围。只讨论适用于局域网的威胁而忽略更广泛的威胁环境是不可接受的。所有IETF标准-轨道协议都被认为有可能在全球互联网上部署。在某些情况下，可能会有一个适用性声明，禁止在特定环境中使用技术或协议。尽管如此，更广泛部署的安全问题应该在文档中讨论。

   There should be a clear description of the residual risk to the user or operator of that protocol after threat mitigation has been deployed.  Such risks might arise from compromise in a related protocol (e.g., IPsec is useless if key management has been compromised), from incorrect implementation, compromise of the security technology used for risk reduction (e.g., a cipher with a 40-bit key), or there might be risks that are not addressed by the protocol specification (e.g., denial of service attacks on an underlying link protocol).  Particular care should be taken in situations where the compromise of a single system would compromise an entire protocol.  For instance, in general protocol designers assume that end-systems are inviolate and don't worry about physical attack.  However, in cases (such as a certificate authority) where compromise of a single system could lead to widespread compromises, it is appropriate to consider systems and physical security as well.

   在部署了威胁缓解措施后，应该对该协议的用户或操作者的剩余风险有一个明确的描述。 这种风险可能来自于相关协议中的妥协（例如，如果密钥管理被破坏，IPsec就没有用了）、不正确的实施、用于降低风险的安全技术被破坏（例如，具有40位密钥的密码），或者可能存在协议规范没有解决的风险（例如，对基础链接协议的拒绝服务攻击）。 在单个系统被破坏会危及整个协议的情况下，应特别小心。 例如，一般来说，协议设计者假设终端系统是不可侵犯的，不担心物理攻击。 然而，在单一系统被破坏可能导致广泛破坏的情况下（如证书机构），也应该考虑系统和物理安全。

   There should also be some discussion of potential security risks arising from potential misapplications of the protocol or technology described in the RFC.  This might be coupled with an Applicability Statement for that RFC.

   还应该讨论RFC中描述的协议或技术的潜在误用所带来的潜在安全风险。这可能与RFC的适用性声明相结合。

## 6. 例子 Examples

   This section consists of some example security considerations sections, intended to give the reader a flavor of what's intended by this document.

   本节包含一些安全注意事项的示例部分，目的是让读者了解本文档的意图。

   The first example is a 'retrospective' example, applying the criteria of this document to an existing widely deployed protocol, SMTP.  The second example is a good security considerations section clipped from a current protocol.

   第一个示例是一个“回顾性”示例，将本文档的标准应用于现有的广泛部署的协议SMTP。第二个示例是从当前协议中截取的一个很好的安全性考虑部分

### 6.1. SMTP

   When RFC 821 was written, Security Considerations sections were not required in RFCs, and none is contained in that document.  [RFC 2821] updated RFC 821 and added a detailed security considerations section. We reproduce here the Security Considerations section from that document (with new section numbers).  Our comments are indented and prefaced with 'NOTE:'.  We also add a number of new sections to cover topics we consider important.  Those sections are marked with [NEW] in the section header.

   在编写RFC 821时，安全考虑部分在RFC中是不需要的，该文件中也没有包含安全考虑。 [RFC 2821]更新了RFC 821并增加了详细的安全考虑部分。我们在此转载了该文件中的安全考虑部分（有新的章节编号）。 我们的评论是缩进的，并在前面加上 "注意："。 我们还增加了一些新的章节来涵盖我们认为重要的主题。 这些部分在章节标题中标有[NEW]。

#### 6.1.1. 安全方面的考虑 Security Considerations

##### 6.1.1.1. 邮件安全和欺骗 Mail Security and Spoofing

   SMTP mail is inherently insecure in that it is feasible for even fairly casual users to negotiate directly with receiving and relaying SMTP servers and create messages that will trick a naive recipient into believing that they came from somewhere else.  Constructing such a message so that the "spoofed" behavior cannot be detected by an expert is somewhat more difficult, but not sufficiently so as to be a deterrent to someone who is determined and knowledgeable. Consequently, as knowledge of Internet mail increases, so does the knowledge that SMTP mail inherently cannot be authenticated, or integrity checks provided, at the transport level.  Real mail security lies only in end-to-end methods involving the message bodies, such as those which use digital signatures (see [14] and, e.g., PGP [4] or S/MIME [31]).

   SMTP邮件本质上是不安全的，因为即使是相当随意的用户也可以直接与接收和转发SMTP服务器进行协商，并创建邮件，从而欺骗天真的收件人相信他们来自其他地方。构建这样一条信息，使专家无法检测到“欺骗”行为，这有点困难，但还不足以威慑意志坚定、知识渊博的人。因此，随着互联网邮件知识的增加，SMTP邮件本身无法在传输级别进行身份验证或提供完整性检查的知识也随之增加。真正的邮件安全性只存在于涉及消息体的端到端方法中，例如使用数字签名的方法（参见[14]和PGP[4]或S/MIME[31]）。

   > *NOTE: One bad approach to sender authentication is [IDENT] in which the receiving mail server contacts the alleged sender and asks for the username of the sender.  This is a bad idea for a number of reasons, including but not limited to relaying, TCP connection hijacking, and simple lying by the origin server. Aside from the fact that IDENT is of low security value, use of IDENT by receiving sites can lead to operational problems.  Many sending sites blackhole IDENT requests, thus causing mail to be held until the receiving server's IDENT request times out.<br>注意：发件人认证的一个坏方法是[IDENT]，即接收邮件的服务器与所谓的发件人联系，询问发件人的用户名。 这是一个坏主意，原因有很多，包括但不限于中继、TCP连接劫持和源服务器的简单撒谎。除了IDENT的安全价值低之外，接收网站使用IDENT会导致操作问题。 许多发送站点对IDENT请求进行黑洞处理，从而导致邮件被扣留，直到接收服务器的IDENT请求超时。*

   Various protocol extensions and configuration options that provide authentication at the transport level (e.g., from an SMTP client to an SMTP server) improve somewhat on the traditional situation described above.  However, unless they are accompanied by careful handoffs of responsibility in a carefully-designed trust environment, they remain inherently weaker than end-to-end mechanisms which use digitally signed messages rather than depending on the integrity of the transport system.

   在传输层面提供认证的各种协议扩展和配置选项（例如，从SMTP客户端到SMTP服务器）在一定程度上改善了上述的传统情况。 然而，除非它们在精心设计的信任环境中伴随着仔细的责任交接，否则它们在本质上仍然比使用数字签名信息而不是依赖传输系统完整性的端到端机制要弱。

   Efforts to make it more difficult for users to set envelope return path and header "From" fields to point to valid addresses other than their own are largely misguided: they frustrate legitimate applications in which mail is sent by one user on behalf of another or in which error (or normal) replies should be directed to a special address.  (Systems that provide convenient ways for users to alter these fields on a per-message basis should attempt to establish a primary and permanent mailbox address for the user so that Sender fields within the message data can be generated sensibly.)

   让用户更难设置信封返回路径和标题“发件人”字段以指向自己以外的有效地址的做法在很大程度上是错误的：它们阻碍了合法的应用程序，在这些应用程序中，邮件由一个用户代表另一个用户发送，或者错误（或正常）回复应指向一个特殊地址。（为用户提供方便的方式，以便在每条邮件的基础上更改这些字段的系统应尝试为用户建立一个主邮箱和永久邮箱地址，以便能够合理地生成邮件数据中的发件人字段。）

   This specification does not further address the authentication issues associated with SMTP other than to advocate that useful functionality not be disabled in the hope of providing some small margin of protection against an ignorant user who is trying to fake mail.

   本规范没有进一步解决与SMTP相关的认证问题，只是主张不要为了提供一些小的保护来防止无知的用户试图伪造邮件而禁用有用的功能。

   > *NOTE: We have added additional material on communications security and SMTP in Section 6.1.2 In a final specification, the above text would be edited somewhat to reflect that fact.<br/>注意：我们在第 6.1.2 节中添加了有关通信安全和 SMTP 的附加材料。在最终规范中，将对上述文本进行一些编辑以反映这一事实。*

##### 6.1.1.2. 密送 Blind Copies

   Addresses that do not appear in the message headers may appear in the RCPT commands to an SMTP server for a number of reasons.  The two most common involve the use of a mailing address as a "list exploder" (a single address that resolves into multiple addresses) and the appearance of "blind copies".  Especially when more than one RCPT command is present, and in order to avoid defeating some of the purpose of these mechanisms, SMTP clients and servers SHOULD NOT copy the full set of RCPT command arguments into the headers, either as part of trace headers or as informational or private-extension headers.  Since this rule is often violated in practice, and cannot be enforced, sending SMTP systems that are aware of "bcc" use MAY find it helpful to send each blind copy as a separate message transaction containing only a single RCPT command.

   出于多种原因，未出现在邮件标头中的地址可能会出现在 SMTP 服务器的 RCPT 命令中。 最常见的两个涉及使用邮寄地址作为“列表扩展器”（一个地址解析为多个地址）和“密送”的出现。 特别是当存在多个 RCPT 命令时，并且为了避免破坏这些机制的某些目的，SMTP 客户端和服务器不应将完整的 RCPT 命令参数集复制到标头中，无论是作为跟踪标头的一部分还是作为 信息或私有扩展标头。 由于此规则在实践中经常被违反，并且无法强制执行，发送知道“密送”使用的 SMTP 系统可能会发现将每个密件副本作为仅包含单个 RCPT 命令的单独消息事务发送是有帮助的。

   There is no inherent relationship between either "reverse" (from MAIL, SAML, etc., commands) or "forward" (RCPT) addresses in the SMTP transaction ("envelope") and the addresses in the headers.  Receiving systems SHOULD NOT attempt to deduce such relationships and use them to alter the headers of the message for delivery.  The popular "Apparently-to" header is a violation of this principle as well as a common source of unintended information disclosure and SHOULD NOT be used.

   在SMTP事务（"信封"）中的 "反向"（来自MAIL、SAML等命令）或 "正向"（RCPT）地址与报头中的地址之间没有任何内在的关系。 接收系统不应试图推断这种关系，并利用它们来改变信息的标题以进行传递。 流行的 "Apparently-to "标头违反了这一原则，也是意外信息泄露的一个常见来源，不应使用。

##### 6.1.1.3. VRFY、EXPN 和安全性 VRFY, EXPN, and Security

   As discussed in section 3.5, individual sites may want to disable either or both of VRFY or EXPN for security reasons.  As a corollary to the above, implementations that permit this MUST NOT appear to have verified addresses that are not, in fact, verified.  If a site disables these commands for security reasons, the SMTP server MUST return a 252 response, rather than a code that could be confused with successful or unsuccessful verification.

   正如第3.5节中所讨论的，出于安全原因，个别站点可能希望禁用VRFY或EXPN中的一个或两个。 作为上述的一个推论，允许这样做的实现不得出现事实上没有被验证过的地址。 如果一个站点出于安全原因禁用这些命令，SMTP服务器必须返回一个252响应，而不是一个可能与成功或不成功的验证相混淆的代码。

   Returning a 250 reply code with the address listed in the VRFY command after having checked it only for syntax violates this rule. Of course, an implementation that "supports" VRFY by always returning 550 whether or not the address is valid is equally not in conformance.

  在只检查了VRFY命令中列出的地址后，返回一个250的回复代码，就违反了这个规则。当然，无论地址是否有效，通过总是返回550来 "支持 "VRFY的实现也同样不符合规定。

   Within the last few years, the contents of mailing lists have become popular as an address information source for so-called "spammers." The use of EXPN to "harvest" addresses has increased as list administrators have installed protections against inappropriate uses of the lists themselves.  Implementations SHOULD still provide support for EXPN, but sites SHOULD carefully evaluate the tradeoffs. As authentication mechanisms are introduced into SMTP, some sites may choose to make EXPN available only to authenticated requesters.

   在过去的几年中，邮件列表的内容已成为所谓的“垃圾邮件发送者”的地址信息来源。 随着列表管理员安装了防止不当使用列表本身的保护措施，使用 EXPN 来“收获”地址的情况有所增加。 实现仍应为 EXPN 提供支持，但站点应仔细评估权衡。 由于 SMTP 中引入了身份验证机制，一些站点可能会选择让 EXPN 仅对经过身份验证的请求者可用。

   > *NOTE: It's not clear that disabling VRFY adds much protection, since it's often possible to discover whether an address is valid using RCPT TO.<br/>注意：目前尚不清楚禁用 VRFY 会增加多少保护，因为通常可以使用 RCPT TO 发现地址是否有效。*

##### 6.1.1.4. Announcements中的信息泄露 Information Disclosure in Announcements

   There has been an ongoing debate about the tradeoffs between the debugging advantages of announcing server type and version (and, sometimes, even server domain name) in the greeting response or in response to the HELP command and the disadvantages of exposing information that might be useful in a potential hostile attack.  The utility of the debugging information is beyond doubt.  Those who argue for making it available point out that it is far better to actually secure an SMTP server rather than hope that trying to conceal known vulnerabilities by hiding the server's precise identity will provide more protection.  Sites are encouraged to evaluate the tradeoff with that issue in mind; implementations are strongly encouraged to minimally provide for making type and version information available in some way to other network hosts.

   关于在问候语中或在对HELP命令的响应中宣布服务器类型和版本（有时甚至是服务器域名）的调试优势与暴露可能对潜在的敌对攻击有用的信息的劣势之间的权衡，一直存在着争论。 调试信息的效用是毫无疑问的。 那些主张提供这些信息的人指出，与其希望通过隐藏服务器的确切身份来掩盖已知的漏洞，不如真正确保SMTP服务器的安全，从而提供更多保护。 我们鼓励网站在评估权衡时考虑到这个问题；我们强烈鼓励实施者以某种方式向其他网络主机提供类型和版本信息的最低限度

##### 6.1.1.5. 跟踪字段的信息泄露 Information Disclosure in Trace Fields

   In some circumstances, such as when mail originates from within a LAN whose hosts are not directly on the public Internet, trace ("Received") fields produced in conformance with this specification may disclose host names and similar information that would not normally be available.  This ordinarily does not pose a problem, but sites with special concerns about name disclosure should be aware of it.  Also, the optional FOR clause should be supplied with caution or not at all when multiple recipients are involved lest it inadvertently disclose the identities of "blind copy" recipients to others.

   在某些情况下，例如，当邮件来自局域网内，其主机不直接在公共互联网上时，按照本规范产生的跟踪（"接收"）字段可能会披露主机名称和类似信息，而这些信息通常是不可用的。 这通常不构成问题，但对名称披露有特殊顾虑的站点应注意到这一点。 另外，当涉及到多个收件人时，应谨慎地提供可选的FOR子句，或者根本不提供，以免无意中向他人披露 "盲目复制 "收件人的身份。

##### 6.1.1.6. 信息转发中的信息泄露 Information Disclosure in Message Forwarding

   As discussed in section 3.4, use of the 251 or 551 reply codes to identify the replacement address associated with a mailbox may inadvertently disclose sensitive information.  Sites that are concerned about those issues should ensure that they select and configure servers appropriately.

   正如第3.4节所讨论的，使用251或551回复代码来识别与邮箱相关的替换地址可能会无意中泄露敏感信息。 担心这些问题的网站应确保他们适当地选择和配置服务器。

##### 6.1.1.7. SMTP服务器的运行范围 Scope of Operation of SMTP Servers

   It is a well-established principle that an SMTP server may refuse to accept mail for any operational or technical reason that makes sense to the site providing the server.  However, cooperation among sites and installations makes the Internet possible.  If sites take excessive advantage of the right to reject traffic, the ubiquity of email availability (one of the strengths of the Internet) will be threatened; considerable care should be taken and balance maintained if a site decides to be selective about the traffic it will accept and process.

   一个公认的原则是，SMTP 服务器可以出于对提供服务器的站点有意义的任何操作或技术原因拒绝接受邮件。 然而，站点和设施之间的合作使互联网成为可能。 如果网站过度利用拒绝流量的权利，电子邮件无处不在（互联网的优势之一）将受到威胁； 如果站点决定对其接受和处理的流量进行选择性处理，则应格外小心并保持平衡。

   In recent years, use of the relay function through arbitrary sites has been used as part of hostile efforts to hide the actual origins of mail.  Some sites have decided to limit the use of the relay function to known or identifiable sources, and implementations SHOULD provide the capability to perform this type of filtering.  When mail is rejected for these or other policy reasons, a 550 code SHOULD be used in response to EHLO, MAIL, or RCPT as appropriate.

   近年来，通过任意站点使用中继功能已被用作隐藏邮件实际来源的敌对行动的一部分。一些站点已决定将中继功能的使用限制在已知或可识别的源上，实现应提供执行此类过滤的能力。当邮件因这些或其他政策原因被拒绝时，应酌情使用550代码回复EHLO、MAIL或RCPT。

##### 6.1.1.8. 不当使用 Inappropriate Usage [NEW]

   SMTP itself provides no protection is provided against unsolicited commercial mass e-mail (aka spam).  It is extremely difficult to tell a priori whether a given message is spam or not.  From a protocol perspective, spam is indistinguishable from other e-mail -- the distinction is almost entirely social and often quite subtle.  (For instance, is a message from a merchant from whom you've purchased items before advertising similar items spam?) SMTP spam-suppression mechanisms are generally limited to identifying known spam senders and either refusing to service them or target them for punishment/disconnection.  [RFC-2505] provides extensive guidance on making SMTP servers spam-resistant.  We provide a brief discussion of the topic here.

   SMTP 本身不提供针对未经请求的商业大量电子邮件（又名垃圾邮件）的保护。 很难先验地判断给定消息是否为垃圾邮件。 从协议的角度来看，垃圾邮件与其他电子邮件没有区别——这种区别几乎完全是社会性的，而且通常非常微妙。 （例如，在宣传类似商品之前，您从该商家那里购买过商品的消息是否为垃圾邮件？）。 [RFC-2505] 提供了关于使 SMTP 服务器抗垃圾邮件的广泛指导。 我们在此处简要讨论该主题。

   The primary tool for refusal to service spammers is the blacklist. Some authority such as [MAPS] collects and publishes a list of known spammers.  Individual SMTP servers then block the blacklisted offenders (generally by IP address).

   拒绝为垃圾邮件发送者提供服务的主要工具是黑名单。 [MAPS] 等一些权威机构收集并发布已知垃圾邮件发送者列表。 然后，各个 SMTP 服务器会阻止列入黑名单的违规者（通常通过 IP 地址）。

   In order to avoid being blacklisted or otherwise identified, spammers often attempt to obscure their identity, either simply by sending a false SMTP identity or by forwarding their mail through an Open Relay -- an SMTP server which will perform mail relaying for any sender. As a consequence, there are now blacklists [ORBS] of open relays as well.

   为了避免被列入黑名单或以其他方式被识别，垃圾邮件发送者经常试图掩盖他们的身份，要么简单地通过发送虚假的 SMTP 身份，要么通过开放中继转发他们的邮件——一个 SMTP 服务器，它将为任何发件人执行邮件中继。 因此，现在也有开放中继的黑名单 [ORBS]。

###### 6.1.1.8.1. 封闭式中继 Closed Relaying [NEW]

   To avoid being used for spam forwarding, many SMTP servers operate as closed relays, providing relaying service only for clients who they can identify.  Such relays should generally insist that senders advertise a sending address consistent with their known identity.  If the relay is providing service for an identifiable network (such as a corporate network or an ISP's network) then it is sufficient to block all other IP addresses).  In other cases, explicit authentication must be used.  The two standard choices for this are TLS [STARTTLS] and SASL [SASLSMTP].

   为了避免被用于垃圾邮件的转发，许多SMTP服务器作为封闭式中继站运行，只为他们能够识别的客户提供中继服务。 这类中继站一般应坚持要求发件人公布一个与其已知身份相一致的发送地址。 如果中继为一个可识别的网络（如公司网络或ISP的网络）提供服务，那么屏蔽所有其他的IP地址就足够了）。 在其他情况下，必须使用明确的认证。 这方面的两个标准选择是TLS [STARTTLS] 和SASL [SASLSMTP]。

###### 6.1.1.8.2. 终端 Endpoints [NEW]

   Realistically, SMTP endpoints cannot refuse to deny service to unauthenticated senders.  Since the vast majority of senders are unauthenticated, this would break Internet mail interoperability. The exception to this is when the endpoint server should only be receiving mail from some other server which can itself receive unauthenticated messages.  For instance, a company might operate a public gateway but configure its internal servers to only talk to the gateway.

   现实上，SMTP终端不能拒绝向未经认证的发件人提供服务。 因为绝大多数的发件人都是未经认证的，这将破坏互联网邮件的互操作性。这方面的例外是，当终端服务器应该只接收来自其他一些服务器的邮件，而这些服务器本身可以接收未经认证的信息。 例如，一家公司可能运营一个公共网关，但将其内部服务器配置为只与网关对话。

#### 6.1.2. 通信安全问题 Communications security issues [NEW]

   SMTP itself provides no communications security, and therefore a large number of attacks are possible.  A passive attack is sufficient to recover the text of messages transmitted with SMTP.  No endpoint authentication is provided by the protocol.  Sender spoofing is trivial, and therefore forging email messages is trivial.  Some implementations do add header lines with hostnames derived through reverse name resolution (which is only secure to the extent that it is difficult to spoof DNS -- not very), although these header lines are normally not displayed to users.  Receiver spoofing is also fairly straight-forward, either using TCP connection hijacking or DNS spoofing.  Moreover, since email messages often pass through SMTP gateways, all intermediate gateways must be trusted, a condition nearly impossible on the global Internet.

   SMTP本身没有提供通信安全，因此大量的攻击是可能的。 被动攻击足以恢复用SMTP传输的信息文本。 该协议没有提供端点认证。 发件人欺骗是微不足道的，因此伪造电子邮件信息也是微不足道的。 一些实施方案确实添加了头行，其中包含通过反向名称解析得出的主机名（这只是在难以欺骗DNS的程度上是安全的 -- 不是很安全），尽管这些头行通常不会显示给用户。 接收者的欺骗也是相当直接的，可以使用TCP连接劫持或DNS欺骗。 此外，由于电子邮件经常通过SMTP网关，所有中间网关都必须被信任，这在全球互联网上几乎是不可能的。

   Several approaches are available for alleviating these threats.  In order of increasingly high level in the protocol stack, we have:

   有几种方法可用于缓解这些威胁。 按照协议栈中越来越高的级别，我们有：

      SMTP over IPSEC
      SMTP/TLS
      S/MIME and PGP/MIME

##### 6.1.2.1. 通过IPSEC的SMTP SMTP over IPSEC [NEW]

   An SMTP connection run over IPSEC can provide confidentiality for the message between the sender and the first hop SMTP gateway, or between any pair of connected SMTP gateways.  That is to say, it provides channel security for the SMTP connections.  In a situation where the message goes directly from the client to the receiver's gateway, this may provide substantial security (though the receiver must still trust the gateway).  Protection is provided against replay attacks, since the data itself is protected and the packets cannot be replayed.

   通过IPSEC运行的SMTP连接可以为发件人和第一跳SMTP网关之间，或任何一对连接的SMTP网关之间的信息提供保密性。 也就是说，它为SMTP连接提供通道安全。 在信息直接从客户端到接收方的网关的情况下，这可能提供实质性的安全（尽管接收方仍然必须信任网关）。 由于数据本身受到保护，数据包不能被重放，因此提供了对重放攻击的保护。

   Endpoint identification is a problem, however, unless the receiver's address can be directly cryptographically authenticated.  Sender identification is not generally available, since generally only the sender's machine is authenticated, not the sender himself. Furthermore, the identity of the sender simply appears in the From header of the message, so it is easily spoofable by the sender. Finally, unless the security policy is set extremely strictly, there is also an active downgrade to cleartext attack.

   然而，端点识别是一个问题，除非接收者的地址可以直接进行加密验证。 发件人的识别通常是不可用的，因为通常只有发件人的机器被认证，而不是发件人本人。此外，发件人的身份只是出现在信息的发件人头中，所以很容易被发件人欺骗。最后，除非安全策略设置得非常严格，否则还存在主动降级为明文的攻击。

   Another problem with IPsec as a security solution for SMTP is the lack of a standard IPsec API.  In order to take advantage of IPsec, applications in general need to be able to instruct the IPsec implementation about their security policies and discover what protection has been applied to their connections.  Without a standard API this is very difficult to do portably.

   IPsec作为SMTP安全解决方案的另一个问题是缺乏一个标准的IPsec API。 为了利用IPsec的优势，一般来说，应用程序需要能够指示IPsec实现他们的安全策略，并发现什么保护已经应用于他们的连接。 如果没有一个标准的 API，这就很难做到可移植性。

   Implementors of SMTP servers or SMTP administrators MUST NOT assume that IPsec will be available unless they have reason to believe that it will be (such as the existence of preexisting association between two machines).  However, it may be a reasonable procedure to attempt to create an IPsec association opportunistically to a peer server when mail is delivered.  Note that in cases where IPsec is used to provide a VPN tunnel between two sites, this is of substantial security value, particularly to the extent that confidentiality is provided, subject to the caveats mentioned above.  Also see [USEIPSEC] for general guidance on the applicability of IPsec.

   SMTP服务器的实施者或SMTP管理员不应假定IPsec是可用的，除非他们有理由相信它是可用的（例如，两台机器之间存在预先存在的关联）。 然而，当邮件被送达时，尝试在对等服务器上创建IPsec关联可能是一个合理的程序。 请注意，在IPsec被用来提供两个站点之间的VPN隧道的情况下，这具有很大的安全价值，特别是在提供保密性的范围内，但要注意上述的注意事项。 关于IPsec的适用性的一般指导，也可参见[USEIPSEC]。

##### 6.1.2.2. SMTP/TLS [NEW]

   SMTP can be combined with TLS as described in [STARTTLS].  This provides similar protection to that provided when using IPSEC.  Since TLS certificates typically contain the server's host name, recipient authentication may be slightly more obvious, but is still susceptible to DNS spoofing attacks.  Notably, common implementations of TLS contain a US exportable (and hence low security) mode.  Applications desiring high security should ensure that this mode is disabled. Protection is provided against replay attacks, since the data itself is protected and the packets cannot be replayed.  [Note:  The Security Considerations section of the SMTP over TLS document is quite good and bears reading as an example of how to do things.]

   SMTP 可以与 [STARTTLS] 中所述的 TLS 结合使用。 这提供了与使用 IPSEC 时提供的保护类似的保护。 由于 TLS 证书通常包含服务器的主机名，因此收件人身份验证可能稍微明显一些，但仍然容易受到 DNS 欺骗攻击。 值得注意的是，TLS 的常见实现包含美国可导出（因此安全性较低）模式。 需要高安全性的应用程序应确保禁用此模式。 提供了针对重放攻击的保护，因为数据本身受到保护并且无法重放数据包。 [注意：SMTP over TLS 文档的安全注意事项部分非常好，值得作为如何做事的示例阅读。]

##### 6.1.2.3. S/MIME 和 PGP/MIME S/MIME and PGP/MIME [NEW]

   S/MIME and PGP/MIME are both message oriented security protocols. They provide object security for individual messages.  With various settings, sender and recipient authentication and confidentiality may be provided.  More importantly, the identification is not of the sending and receiving machines, but rather of the sender and recipient themselves.  (Or, at least, of cryptographic keys corresponding to the sender and recipient.)  Consequently, end-to-end security may be obtained.  Note, however, that no protection is provided against replay attacks.  Note also that S/MIME and PGP/MIME generally provide identifying marks for both sender and receiver. Thus even when confidentiality is provided, traffic analysis is still possible.

   S/MIME 和 PGP/MIME 都是面向消息的安全协议。 它们为单个消息提供对象安全性。 通过各种设置，可以提供发件人和收件人身份验证和保密性。 更重要的是，识别不是发送和接收机器，而是发送者和接收者本身。 (或者，至少，对应于发送者和接收者的密码密钥。)因此，可以获得端到端的安全性。 但是请注意，没有提供针对重放攻击的保护。 另请注意，S/MIME 和 PGP/MIME 通常为发送者和接收者提供识别标记。 因此，即使提供了机密性，仍然可以进行流量分析。

#### 6.1.3. 拒绝服务 Denial of Service [NEW]

   None of these security measures provides any real protection against denial of service.  SMTP connections can easily be used to tie up system resources in a number of ways, including excessive port consumption, excessive disk usage (email is typically delivered to disk files), and excessive memory consumption (sendmail, for instance, is fairly large, and typically forks a new process to deal with each message.)

   这些安全措施都没有提供任何针对拒绝服务的真正保护。 SMTP 连接可以很容易地以多种方式占用系统资源，包括过多的端口消耗、过多的磁盘使用（电子邮件通常传送到磁盘文件）和过多的内存消耗（例如，sendmail 相当大，并且 通常会派生一个新进程来处理每条消息。）

   If transport- or application-layer security is used for SMTP connections, it is possible to mount a variety of attacks on individual connections using forged RSTs or other kinds of packet injection.

   如果将传输层或应用层安全用于 SMTP 连接，则可以使用伪造的 RST 或其他类型的数据包注入对单个连接进行各种攻击。

### 6.2. VRRP

   The second example is from VRRP, the Virtual Router Redundance Protocol ([VRRP]).  We reproduce here the Security Considerations section from that document (with new section numbers).  Our comments are indented and prefaced with 'NOTE:'.

   第二个示例来自 VRRP，即虚拟路由器冗余协议 ([VRRP])。 我们在此处复制了该文档中的安全注意事项部分（带有新的部分编号）。 我们的评论缩进并以 “ 注意：” 开头。

##### 6.2.1. 安全注意事项 Security Considerations

   VRRP is designed for a range of internetworking environments that may employ different security policies.  The protocol includes several authentication methods ranging from no authentication, simple clear text passwords, and strong authentication using IP Authentication with MD5 HMAC.  The details on each approach including possible attacks and recommended environments follows.

   VRRP 专为可能采用不同安全策略的一系列互联网络环境而设计。 该协议包括多种身份验证方法，包括无身份验证、简单明文密码和使用带有 MD5 HMAC 的 IP 身份验证的强身份验证。 以下是每种方法的详细信息，包括可能的攻击和推荐的环境。

   Independent of any authentication type VRRP includes a mechanism (setting TTL=255, checking on receipt) that protects against VRRP packets being injected from another remote network.  This limits most vulnerabilities to local attacks.

   独立于任何身份验证类型的 VRRP 包括一种机制（设置 TTL=255，检查接收），以防止 VRRP 数据包从另一个远程网络注入。 这将大多数漏洞限制为本地攻击。

  > *NOTE: The security measures discussed in the following sections only provide various kinds of authentication.  No confidentiality is provided at all.  This should be explicitly described as outside the scope.<br/>注意：以下部分中讨论的安全措施仅提供各种身份验证。 根本不提供任何机密性。 这应该被明确描述为超出范围。 *

###### 6.2.1.1. 无身份验证 No Authentication

   The use of this authentication type means that VRRP protocol exchanges are not authenticated.  This type of authentication SHOULD only be used in environments were there is minimal security risk and little chance for configuration errors (e.g., two VRRP routers on a LAN).

   使用这种身份验证类型意味着VRRP协议交换未经身份验证。只有在安全风险最小且配置错误的可能性很小的环境中（例如，局域网上的两个VRRP路由器），才应使用这种类型的身份验证。

###### 6.2.1.2. 简单文本密码 Simple Text Password

   The use of this authentication type means that VRRP protocol exchanges are authenticated by a simple clear text password.

   使用这种身份验证类型意味着VRRP协议交换通过简单的明文密码进行身份验证。

   This type of authentication is useful to protect against accidental misconfiguration of routers on a LAN.  It protects against routers inadvertently backing up another router.  A new router must first be configured with the correct password before it can run VRRP with another router.  This type of authentication does not protect against hostile attacks where the password can be learned by a node snooping VRRP packets on the LAN.  The Simple Text Authentication combined with the TTL check makes it difficult for a VRRP packet to be sent from another LAN to disrupt VRRP operation.

   这种类型的认证对于防止局域网上的路由器意外的错误配置很有用。 它可以防止路由器无意中备份另一台路由器。 一个新的路由器必须首先配置正确的密码，然后才能与另一个路由器一起运行VRRP。 这种类型的认证不能防止敌对的攻击，在这种情况下，密码可以被局域网上窥探VRRP数据包的节点所了解。 简单文本认证与TTL检查相结合，使得从另一个局域网发送的VRRP数据包难以破坏VRRP的运行。

   This type of authentication is RECOMMENDED when there is minimal risk of nodes on a LAN actively disrupting VRRP operation.  If this type of authentication is used the user should be aware that this clear text password is sent frequently, and therefore should not be the same as any security significant password.

   当局域网上的节点主动破坏VRRP运行的风险最小时，建议使用这种类型的验证。 如果使用这种类型的认证，用户应该意识到这种明文密码是经常发送的，因此不应该与任何有安全意义的密码相同。

   > *NOTE: This section should be clearer.  The basic point is that no authentication and Simple Text are only useful for a very limited threat model, namely that none of the nodes on the local LAN are hostile.  The TTL check prevents hostile nodes off-LAN from posing as valid nodes, but nothing stops hostile nodes on-LAN from impersonating authorized nodes.  This is not a particularly realistic threat model in many situations.  In particular, it's extremely brittle: the compromise of any node the LAN allows reconfiguration of the VRRP nodes.<br/>注意：这一节应该更清楚。 基本观点是，无认证和简单文本只对非常有限的威胁模型有用，即本地LAN上没有一个节点是敌对的。 TTL检查可以防止局域网外的敌对节点冒充有效节点，但没有任何东西可以阻止局域网内的敌对节点冒充授权节点。 在许多情况下，这不是一个特别现实的威胁模型。 特别是，它是非常脆弱的：局域网中任何节点的妥协都允许重新配置VRRP节点。*

##### 6.2.1.3. IP认证报头 IP Authentication Header

   The use of this authentication type means the VRRP protocol exchanges are authenticated using the mechanisms defined by the IP Authentication Header [AH] using [HMAC].  This provides strong protection against configuration errors, replay attacks, and packet corruption/modification.

   使用这种身份验证类型意味着 VRRP 协议交换使用 IP 身份验证标头 [AH] 使用 [HMAC] 定义的机制进行身份验证。 这提供了针对配置错误、重放攻击和数据包损坏/修改的强大保护。

   This type of authentication is RECOMMENDED when there is limited control over the administration of nodes on a LAN.  While this type of authentication does protect the operation of VRRP, there are other types of attacks that may be employed on shared media links (e.g., generation of bogus ARP replies) which are independent from VRRP and are not protected.

   当对 LAN 上节点的管理控制有限时，建议使用这种类型的身份验证。 虽然这种类型的身份验证确实保护了 VRRP 的运行，但在共享媒体链路上可能会采用其他类型的攻击（例如，生成虚假的 ARP 回复），这些攻击独立于 VRRP 并且不受保护。

  > *NOTE: It's a mistake to have AH be a RECOMMENDED in this context. Since AH is the only mechanism that protects VRRP against attack from other nodes on the same LAN, it should be a MUST for cases where there are untrusted nodes on the same network.  In any case, AH should be a MUST implement.<br/>注意：在这种情况下，将AH作为推荐值是错误的。由于AH是保护VRRP免受同一LAN上其他节点攻击的唯一机制，因此在同一网络上存在不受信任节点的情况下，AH应该是必须的。在任何情况下，啊都应该是必须实施的。*

   > *NOTE: There's an important piece of security analysis that's only hinted at in this document, namely the cost/benefit tradeoff of VRRP authentication.<br/>注意：本文档中仅暗示了一个重要的安全分析，即VRRP身份验证的成本/收益权衡。*

   [The rest of this section is NEW material]
   [本节其余部分为新材料]

   The threat that VRRP authentication is intended to prevent is an attacker arranging to be the VRRP master.  This would be done by joining the group (probably multiple times), gagging the master and then electing oneself master.  Such a node could then direct traffic in arbitrary undesirable ways.

   VRRP认证旨在防止的威胁是攻击者安排成为VRRP主机。 这将通过加入组（可能是多次），阻塞主机，然后选举自己成为主机来实现。 这样一个节点就可以以任意的不受欢迎的方式引导流量。

   However, it is not necessary for an attacker to be the VRRP master to do this.  An attacker can do similar kinds of damage to the network by forging ARP packets or (on switched networks) fooling the switch VRRP authentication offers no real protection against these attacks.

   然而，攻击者没有必要成为VRRP主机来做这件事。 攻击者可以通过伪造ARP数据包或（在交换式网络上）愚弄交换机对网络进行类似的破坏，VRRP认证对这些攻击没有提供真正的保护。

   Unfortunately, authentication makes VRRP networks very brittle in the face of misconfiguration.  Consider what happens if two nodes are configured with different passwords.  Each will reject messages from the other and therefore both will attempt to be master.  This creates substantial network instability.

   不幸的是，认证使VRRP网络在面对错误配置时非常脆弱。 考虑一下如果两个节点被配置成不同的密码会发生什么。 每个节点都会拒绝来自另一个节点的消息，因此都会试图成为主节点。 这就造成了大量的网络不稳定

   This set of cost/benefit tradeoffs suggests that VRRP authentication is a bad idea, since the incremental security benefit is marginal but the incremental risk is high.  This judgment should be revisited if the current set of non-VRRP threats are removed.

   这组成本/收益权衡表明，VRRP认证是一个坏主意，因为增量的安全收益是微不足道的，但增量的风险却很高。 如果目前的一系列非VRRP威胁被消除，应该重新审视这一判断。

## 7. 致谢 Acknowledgments

   This document is heavily based on a note written by Ran Atkinson in 1997.  That note was written after the IAB Security Workshop held in early 1997, based on input from everyone at that workshop.  Some of the specific text above was taken from Ran's original document, and some of that text was taken from an email message written by Fred Baker.  The other primary source for this document is specific comments received from Steve Bellovin.  Early review of this document was done by Lisa Dusseault and Mark Schertler.  Other useful comments were received from Bill Fenner, Ned Freed, Lawrence Greenfield, Steve Kent, Allison Mankin and Kurt Zeilenga.

   本文档主要基于 Ran Atkinson 在 1997 年撰写的一份说明。该说明是在 1997 年初举行的 IAB 安全研讨会之后根据该研讨会上每个人的意见编写的。 上面的一些特定文本来自 Ran 的原始文档，其中一些文本来自 Fred Baker 写的一封电子邮件。 本文档的另一个主要来源是从 Steve Bellovin 收到的具体评论。 Lisa Dusseault 和 Mark Schertler 对本文档进行了早期审查。 其他有用的评论来自 Bill Fenner、Ned Freed、Lawrence Greenfield、Steve Kent、Allison Mankin 和 Kurt Zeilenga。

## 8. 引用标准 Normative References

   [AH]       Kent, S. and R. Atkinson, "IP Authentication Header", RFC 2402, November 1998.

   [DNSSEC]   Eastlake, D., "Domain Name System Security Extensions", RFC 2535, March 1999.

   [ENCOPT]   Tso, T., "Telnet Data Encryption Option", RFC 2946, September, 2000.

   [ESP]      Kent, S. and R. Atkinson, "IP Encapsulating Security Payload (ESP)", RFC 2406, November 1998.

   [GSS]      Linn, J., "Generic Security Services Application Program Interface Version 2, Update 1", RFC 2743, January 2000.

   [HTTP]     Fielding, R., Gettys, J., Mogul, J., Frystyk, H., Masinter, L., Leach, P. and T. Berners-Lee, "HyperText Transfer Protocol", RFC 2616, June 1999.

   [HTTPTLS]  Rescorla, E., "HTTP over TLS", RFC 2818, May 2000.

   [HMAC]     Madson, C. and R. Glenn, "The Use of HMAC-MD5-96 within ESP and AH", RFC 2403, November 1998.

   [KERBEROS]  Kohl, J. and C. Neuman, "The Kerberos Network Authentication Service (V5)", RFC 1510, September 1993.

   [KEYWORDS] Bradner, S., "Key words for use in RFCs to Indicate Requirement Levels", BCP 14, RFC 2119, March 1997.

   [OTP]      Haller, N., Metz, C., Nesser, P. and M. Straw, "A One-Time Password System", STD 61, RFC 2289, February 1998.

   [PHOTURIS] Karn, P. and W. Simpson, "Photuris: Session-Key Management Protocol", RFC 2522, March 1999.

   [PKIX]     Housley, R., Polk, W., Ford, W. and D. Solo, "Internet X.509 "Public Key Infrastructure Certificate and Certificate Restoration List (CRL) Profile", RFC 3280, April 2002.

   [RFC-2223] Postel J. and J. Reynolds, "Instructions to RFC Authors", RFC 2223, October 1997.

   [RFC-2505] Lindberg, G., "Anti-Spam Recommendations for SMTP MTAs", BCP 30, RFC 2505, February 1999.

   [RFC-2821] Klensin, J., "Simple Mail Transfer Protocol", RFC 2821, April 2001.

   [SASL]     Myers, J., "Simple Authentication and Security Layer (SASL)", RFC 2222, October 1997.

   [SPKI]     Ellison, C., Frantz, B., Lampson, B., Rivest, R., Thomas, B. and T. Ylonen, "SPKI Certificate Theory",  RFC 2693, September 1999.

   [SSH]      Ylonen, T., "SSH - Secure Login Connections Over the Internet", 6th USENIX Security Symposium, p. 37-42, July 1996.

   [SASLSMTP] Myers, J., "SMTP Service Extension for Authentication", RFC 2554, March 1999.

   [STARTTLS] Hoffman, P., "SMTP Service Extension for Secure SMTP over Transport Layer Security", RFC 3207, February 2002.

   [S-HTTP]   Rescorla, E. and A. Schiffman, "The Secure HyperText Transfer Protocol", RFC 2660, August 1999.

   [S/MIME]   Ramsdell, B., Editor, "S/MIME Version 3 Message Specification", RFC 2633, June 1999.

   [TELNET]   Postel, J. and J. Reynolds, "Telnet Protocol Specification", STD 8, RFC 854, May 1983.

   [TLS]      Dierks, T. and C. Allen, "The TLS Protocol Version 1.0", RFC 2246, January 1999.

   [TLSEXT]   Blake-Wilson, S., Nystrom, M., Hopwood, D. and J. Mikkelsen, "Transport Layer Security (TLS) Extensions", RFC 3546, May 2003.

   [TCPSYN]   "TCP SYN Flooding and IP Spoofing Attacks", CERT Advisory CA-1996-21, 19 September 1996, CERT.http://www.cert.org/advisories/CA-1996-21.html

   [UPGRADE]  Khare, R. and S. Lawrence, "Upgrading to TLS Within HTTP/1.1", RFC 2817, May 2000.

   [URL]      Berners-Lee, T., Masinter, M. and M. McCahill, "Uniform Resource Locators (URL)", RFC 1738, December 1994.

   [VRRP]     Knight, S., Weaver, D., Whipple, D., Hinden, R., Mitzel, D., Hunt, P., Higginson, P., Shand, M. and A. Lindemn, "Virtual Router Redundancy Protocol", RFC 2338, April 1998.

## 9. 参考资料 Informative References

   [DDOS]     "Denial-Of-Service Tools" CERT Advisory CA-1999-17, 28 December 1999, CERT http://www.cert.org/advisories/CA-1999-17.html

   [EKE]      Bellovin, S., Merritt, M., "Encrypted Key Exchange: Password-based protocols secure against dictionary attacks", Proceedings of the IEEE Symposium on Research in Security and Privacy, May 1992.

   [IDENT]    St. Johns, M. and M. Rose, "Identification Protocol", RFC 1414, February 1993.

   [INTAUTH]  Haller, N. and R. Atkinson, "On Internet Authentication",RFC 1704, October 1994.

   [IPSPPROB] Bellovin, S. M., "Problem Areas for the IP Security Protocols", Proceedings of the Sixth Usenix UNIX Security Symposium, July 1996.

   [KLEIN]    Klein, D.V., "Foiling the Cracker: A Survey of and Improvements to Password Security",  1990.

   [NNTP]     Kantor, B. and P. Lapsley, "Network News Transfer Protocol", RFC 977, February 1986.

   [POP]      Myers, J. and M. Rose, "Post Office Protocol - Version 3",STD 53, RFC 1939, May 1996.

   [SEQNUM]   Morris, R.T., "A Weakness in the 4.2 BSD UNIX TCP/IP Software", AT&T Bell Laboratories, CSTR 117, 1985.

   [SOAP]     Box, D., Ehnebuske, D., Kakivaya, G., Layman, A., Mendelsoh, N., Nielsen, H., Thatte, S., Winer, D., "Simple Object Access Protocol (SOAP) 1.1", May 2000.

   [SPEKE]    Jablon, D., "Strong Password-Only Authenticated Key Exchange", Computer Communication Review, ACM SIGCOMM, vol. 26, no. 5, pp. 5-26, October 1996.

   [SRP]      Wu T., "The Secure Remote Password Protocol", ISOC NDSS Symposium, 1998.

   [USEIPSEC] Bellovin, S., "Guidelines for Mandating the Use of IPsec",Work in Progress.

   [WEP]      Borisov, N., Goldberg, I., Wagner, D., "Intercepting Mobile Communications: The Insecurity of 802.11",http://www.isaac.cs.berkeley.edu/isaac/wep-draft.pdf

## 10. 安全注意事项 Security Considerations

   This entire document is about security considerations.

   整个文档都是关于安全考虑的。

## 附录 A Appendix A.

   IAB Members at the time of this writing

   撰写本文时的 IAB 成员

   Harald Alvestrand
   Ran Atkinson
   Rob Austein
   Fred Baker
   Leslie Daigle
   Steve Deering
   Sally Floyd
   Ted Hardie
   Geoff Huston
   Charlie Kaufman
   James Kempf
   Eric Rescorla
   Mike St. Johns

## 作者地址 Authors' Addresses

   Eric Rescorla
   RTFM, Inc.
   2439 Alvin Drive
   Mountain View, CA 94043

   Phone: (650)-320-8549
   EMail: ekr@rtfm.com


   Brian Korver
   Xythos Software, Inc.
   77 Maiden Lane, 6th Floor
   San Francisco, CA, 94108

   Phone: (415)-248-3800
   EMail: briank@xythos.com


   Internet Architecture Board
   IAB
   EMail: iab@iab.org

## 完整的版权声明 Full Copyright Statement

   Copyright (C) The Internet Society (2003).  All Rights Reserved.

   This document and translations of it may be copied and furnished to others, and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared, copied, published and distributed, in whole or in part, without restriction of any kind, provided that the above copyright notice and this paragraph are included on all such copies and derivative works.  However, this document itself may not be modified in any way, such as by removing the copyright notice or references to the Internet Society or other Internet organizations, except as needed for the purpose of developing Internet standards in which case the procedures for copyrights defined in the Internet Standards process must be followed, or as required to translate it into languages other than English.

   本文件及其翻译可以复制和提供给其他人，对其发表评论或以其他方式解释或协助其实施的衍生作品可以全部或部分编写、复制、出版和分发，不受任何形式的限制 , 前提是上述版权声明和本段包含在所有此类副本和衍生作品中。 但是，不得以任何方式修改本文档本身，例如删除版权声明或对 Internet 协会或其他 Internet 组织的引用，除非出于开发 Internet 标准的需要，在这种情况下，版权程序定义在 必须遵循互联网标准流程，或根据需要将其翻译成英语以外的其他语言。

   The limited permissions granted above are perpetual and will not be revoked by the Internet Society or its successors or assigns.

   上述授予的有限权限是永久性的，不会被互联网协会或其继任者或受让人撤销。

   This document and the information contained herein is provided on an "AS IS" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.

   本文档和此处包含的信息按“原样”提供，互联网协会和互联网工程工作组不提供任何明示或暗示的保证，包括但不限于使用此处信息不会做出的任何保证 侵犯任何权利或任何对适销性或特定用途适用性的默示保证。

## 致谢 Acknowledgement

   Funding for the RFC Editor function is currently provided by the Internet Society.

   RFC Editor 功能的资金目前由 Internet Society 提供。
